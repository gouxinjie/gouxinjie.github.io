# 计算属性：提升开发效率的利器

## 什么是计算属性？

计算属性是 `Vue.js` 中一个非常强大的特性，它允许你声明式地定义依赖于其他数据的属性。计算属性的值会被缓存，只有在其依赖的数据发生变化时才会重新计算。

```javascript
export default {
  data() {
    return {
      firstName: "张",
      lastName: "三"
    };
  },
  computed: {
    fullName() {
      return this.firstName + " " + this.lastName;
    }
  }
};
```

## 为什么需要计算属性？

### 1. 解决模板内复杂逻辑问题

当模板中的表达式变得复杂时，例如：

```html
<div>{{ firstName + ' ' + lastName }}</div>
```

计算属性可以让模板保持简洁和可读性：

```html
<div>{{ fullName }}</div>
```

### 2. 数据缓存提高性能

计算属性基于它们的依赖进行缓存，只有在相关依赖改变时才会重新计算。相比之下，方法调用总是会执行函数。

### 3. 响应式依赖追踪

计算属性会自动追踪其依赖的数据，当依赖变化时，计算属性会自动更新。

## 计算属性 vs 方法

| 特性         | 计算属性               | 方法                  |
| ------------ | ---------------------- | --------------------- |
| **缓存**     | 有缓存                 | 无缓存                |
| **调用方式** | 像属性一样访问         | 需要调用              |
| **适用场景** | 基于依赖的计算         | 需要每次执行的操作    |
| **语法**     | 在 computed 选项中定义 | 在 methods 选项中定义 |

## 计算属性 vs 侦听器(watch)

虽然侦听器也能观察数据变化，但计算属性通常是更好的选择：

```javascript
// 使用watch实现fullName
watch: {
  firstName(val) {
    this.fullName = val + ' ' + this.lastName
  },
  lastName(val) {
    this.fullName = this.firstName + ' ' + val
  }
}

// 使用computed更简洁
computed: {
  fullName() {
    return this.firstName + ' ' + this.lastName
  }
}
```

## 计算属性的高级用法

### 1. 可写的计算属性

计算属性默认只有 getter，但你可以提供一个 setter：

```javascript
computed: {
  fullName: {
    get() {
      return this.firstName + ' ' + this.lastName
    },
    set(newValue) {
      const names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
```

### 2. 依赖多个数据源

```javascript
computed: {
  totalPrice() {
    return this.quantity * this.unitPrice * (1 - this.discount)
  }
}
```

### 3. 过滤和排序列表

```javascript
computed: {
  filteredUsers() {
    return this.users.filter(user =>
      user.name.includes(this.searchQuery)
  },
  sortedProducts() {
    return [...this.products].sort((a, b) =>
      this.sortOrder === 'asc' ? a.price - b.price : b.price - a.price)
  }
}
```

## 计算属性的最佳实践

1. **保持纯净**：计算属性应该是纯函数，不要在其中执行异步操作或修改 DOM

2. **避免副作用**：不要在计算属性中修改其他数据

3. **合理命名**：使用描述性的名称，如`formattedDate`而不是`date`

4. **复杂计算拆分**：将复杂计算拆分为多个计算属性，提高可读性和可维护性

5. **性能优化**：对于计算密集型的操作，考虑使用缓存或记忆化

## 常见问题解答

### Q1: 计算属性可以异步吗？

计算属性不应该包含异步操作，如果需要异步处理数据，可以考虑使用方法或结合 watch。

### Q2: 计算属性能接收参数吗？

不能直接接收参数，但你可以返回一个函数来达到类似效果：

```javascript
computed: {
  getItemById() {
    return (id) => this.items.find(item => item.id === id)
  }
}
// 使用: getItemById(5)
```

### Q3: 什么时候应该使用计算属性而不是 watch？

当你需要基于其他数据计算一个值时使用计算属性；当你需要在数据变化时执行操作或异步任务时使用 watch。

## 实际应用案例

### 案例 1：购物车总计

```javascript
computed: {
  cartTotal() {
    return this.cartItems.reduce((total, item) => {
      return total + (item.price * item.quantity)
    }, 0)
  },
  formattedTotal() {
    return '¥' + this.cartTotal.toFixed(2)
  }
}
```

### 案例 2：表单验证

```javascript
computed: {
  emailError() {
    if (!this.email) return '邮箱不能为空'
    if (!/^\w+@\w+\.\w+$/.test(this.email)) return '邮箱格式不正确'
    return ''
  },
  isFormValid() {
    return !this.emailError && this.password.length >= 6
  }
}
```