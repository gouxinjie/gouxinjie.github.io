# 解决发版后手动清除浏览器缓存的问题

[[toc]]

> 在前端开发中，浏览器缓存是一个常见而棘手的问题。每当我们更新代码并进行发版时，用户的浏览器可能会继续使用缓存中的旧资源，这会导致用户看到过时的页面或出现错误。特别是在 **JavaScript**、**CSS** 或 **HTML** 资源发生变化时，如果缓存没有及时更新，用户体验会大打折扣。

## 一、为什么会出现缓存问题？

浏览器使用缓存来加速页面加载，避免每次访问时都重新下载所有资源。缓存的机制可以大大提高性能，但在某些情况下也会导致问题。最常见的问题是 **浏览器缓存了旧的资源**，即便你已经发版并更新了文件，用户仍然会看到缓存中的过期内容。

### 常见缓存问题

- **JavaScript 或 CSS 更新后，页面仍然使用旧文件**
- **浏览器加载过期的 `index.html` 文件**
- **图片或其他静态资源未更新，导致展示错误**

## 二、如何解决浏览器缓存问题？

### 1. **文件版本化（Cache Busting）**

最常见的做法是给文件名加上 **版本号** 或 **哈希值**。每当文件内容发生变化时，文件名也会随之变化，从而强制浏览器重新加载新文件，而不是使用缓存中的旧版本。

#### 实现方式：

- **JavaScript** 和 **CSS** 文件通常通过在文件名中添加内容哈希来实现版本控制（例如 `main.12345.js`）。
- **前端构建工具**（如 **Webpack**、**Vite** 等）都内置了文件版本化的功能，在构建过程中自动生成带有哈希值的文件名。

**Webpack 配置示例**：

```js
module.exports = {
  output: {
    filename: "[name].[contenthash].js", // 为每个输出的文件添加 contenthash
    path: path.resolve(__dirname, "dist")
  }
};
```

这种做法可以确保文件一旦更新，浏览器就会自动下载新的文件，而不会缓存旧的版本。

### 2. 利用 Nginx 配置清除缓存

如果你使用 **Nginx** 作为 Web 服务器，你可以通过配置缓存策略来控制哪些资源应该被缓存，哪些资源需要始终重新加载。

#### 配置方法：

在 Nginx 配置中，为 `index.html` 文件设置 **不缓存** 的策略，同时为其他静态资源（如 JS、CSS）设置 **长期缓存**。

**Nginx 配置示例**：

```nginx

# 这是最关键的一步，确保浏览器总是获取最新的入口文件。
location = /index.html {
    add_header Cache-Control "no-cache, no-store, must-revalidate";
    add_header Pragma "no-cache";
    add_header Expires "0";
}

 # 这些文件通常不带 Hash，但也不常变动，可以设置一个较长的缓存时间。
 location ~* .(jpg|jpeg|png|gif|ico|svg|woff|woff2|ttf)$ {
    expires 30d;
    add_header Cache-Control "public";
 }
```

- 对于 `index.html` 文件，使用 `Cache-Control: no-cache, no-store` 确保每次访问时都加载最新版本。
- 对于其他静态资源（字体、图片等），在浏览器和 CDN 里安心缓存 30 天，减少重复请求，提升性能。

#### 解释：

- **`no-cache`**: 强制浏览器每次验证缓存是否过期。
- **`no-store`**: 完全不缓存内容，每次请求都会重新获取最新文件。
- **`max-age=31536000`**: 表示静态资源可以缓存一年。
- **`immutable`**: 资源不可变，意味着资源不会变化，浏览器可以不检查过期。

这种方法保证了每次访问 `index.html` 时都能加载最新版本，同时其他资源如 JS、CSS 文件在没有发生变化时会保持长时间缓存，避免不必要的请求。

### 3. 利用 HTML Meta 标签中的 cache-control

通过在 HTML 的`<head>`部分添加` <meta>` 标签来控制缓存策略。虽然这种方式不如 Cache-Control 头部灵活和强大，但它也能控制某些页面的缓存行为。

#### 示例：

```html
<head>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
</head>
```

::: warning 注意

「HTTP 响应头（Response Headers）的优先级 > HTML Meta 标签

:::

没错，`meta ` 标签更像是一种 “建议”，而由服务器（如 Nginx）在 `HTTP` 响应中返回的 ` Cache-Control、Expires`  等头部信息，才是浏览器必须严格遵守的 “最高指令”。如果 `HTTP` 响应头没有明确指示不缓存，或者指示了可以缓存，那么浏览器就会愉快地忽略 `meta` 标签的建议，将 ` index.html`  缓存起来。
