# 软件设计五大核心原则

## 1. YAGNI - 你不会需要它

**核心思想**：不要写不需要的代码

**实践建议**：

- 基于明确需求开发，而非假设
- 避免过度设计和过早优化
- 需要时再重构，而非预先设计

**示例**：

```javascript
// 不好：预先实现多种数据库支持
class Database {
  supportMySQL() {}
  supportMongo() {}
}

// 好：只实现当前需要的
class MySQLDatabase {
  connect() {}
}
```

## 2. DRY - 不要重复自己

**核心思想**：避免代码重复，提高复用性

**实践建议**：

- 提取公共逻辑为函数/模块
- 使用抽象和封装
- 定期审查代码发现重复

**示例**：

```javascript
// 不好：重复验证逻辑
function valUser(u) {
  if (!u.name) throw Error();
}
function valProduct(p) {
  if (!p.name) throw Error();
}

// 好：提取公共方法
function validateName(value) {
  if (!value) throw Error();
}
```

## 3. OCP - 开闭原则

**核心思想**：对扩展开放，对修改关闭

**实践建议**：

- 通过添加新代码扩展功能
- 使用抽象和接口定义契约
- 优先使用组合而非继承

**示例**：

```javascript
// 不好：添加新形状需修改现有代码
class AreaCalculator {
  area(shape) {
    if (shape.type === "circle") return PI * shape.r * shape.r;
    // 添加新形状需要修改这里
  }
}

// 好：通过扩展实现新功能
class Shape {
  area() {}
}
class Circle extends Shape {
  area() {
    return PI * this.r * this.r;
  }
}
```

## 4. 高内聚低耦合

**核心思想**：模块内部紧密相关，模块之间依赖最少

**实践建议**：

- 分离关注点，明确模块职责
- 使用依赖注入降低耦合
- 定义清晰模块边界

**示例**：

```javascript
// 不好：高耦合
class UserManager {
  constructor() {
    this.db = new MySQL(); // 紧耦合
    this.email = new Email(); // 紧耦合
  }
}

// 好：低耦合
class UserManager {
  constructor(db, email) {
    // 依赖抽象
    this.db = db;
    this.email = email;
  }
}
```

## 5. 迪米特法则

**核心思想**：最少知识原则，只与直接朋友通信

**实践建议**：

- 减少对象间的依赖
- 使用封装隐藏实现细节
- 避免过长的调用链

**示例**：

```javascript
// 不好：了解过多细节
order.getCustomer().getAddress().getCity();

// 好：减少知识依赖
order.getCustomerCity();
```

## 总结

| 原则         | 核心思想     | 关键实践     |
| ------------ | ------------ | ------------ |
| YAGNI        | 不做过度设计 | 需要时才实现 |
| DRY          | 避免重复     | 抽象和封装   |
| OCP          | 扩展而非修改 | 使用抽象接口 |
| 高内聚低耦合 | 模块化设计   | 分离关注点   |
| 迪米特法则   | 减少依赖     | 封装细节     |
