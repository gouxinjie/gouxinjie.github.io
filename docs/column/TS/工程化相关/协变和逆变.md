# TypeScript 中的协变与逆变：理解类型系统的核心概念

## 引言

在 `TypeScript` 的类型系统中，`协变（Covariance）和逆变（Contravariance）`是两个重要但常被忽视的概念。它们描述了类型关系在不同上下文中的表现方式，对于构建类型安全的复杂系统至关重要。

## 基本概念

### 什么是变体（Variance）？

变体描述了复杂类型（如泛型、函数）如何基于其组成部分的类型保持或反转子类型关系。主要有四种变体：

1. **协变（Covariance）**：保持子类型关系
2. **逆变（Contravariance）**：反转子类型关系
3. **双变（Bivariance）**：同时支持协变和逆变
4. **不变（Invariance）**：既不协变也不逆变

## 协变（Covariance）

### 定义

协变表示如果 `A` 是 `B` 的子类型，那么 `Container<A>` 也是 `Container<B>` 的子类型。

### 示例

```typescript
class Animal {
  name: string;
}

class Dog extends Animal {
  breed: string;
}

// 协变示例：数组类型
let animals: Animal[] = [];
let dogs: Dog[] = [];

animals = dogs; // 合法，因为 Dog[] 是 Animal[] 的子类型
// dogs = animals; // 不合法，因为 Animal[] 不是 Dog[] 的子类型
```

在这个例子中，`Dog[]` 可以赋值给 `Animal[]`，因为 `Dog` 是 `Animal` 的子类型，数组类型保持了这种子类型关系，这就是协变。

## 逆变（Contravariance）

### 定义

逆变表示如果 `A` 是 `B` 的子类型，那么 `Container<B>` 是 `Container<A>` 的子类型（与协变相反）。

### 示例

逆变最常见于函数参数位置：

```typescript
type AnimalHandler = (animal: Animal) => void;
type DogHandler = (dog: Dog) => void;

let handleAnimal: AnimalHandler = (animal: Animal) => {
  console.log(animal.name);
};

let handleDog: DogHandler = (dog: Dog) => {
  console.log(dog.breed);
};

// 逆变示例：函数参数类型
handleDog = handleAnimal; // 合法
// handleAnimal = handleDog; // 不合法（除非开启 strictFunctionTypes）
```

这里，`AnimalHandler` 可以赋值给 `DogHandler`，因为 `Animal` 是 `Dog` 的超类型。函数参数类型反转了子类型关系，这就是逆变。

## TypeScript 中的变体规则

1. **方法参数**：默认双变（为了兼容性），可通过 `strictFunctionTypes` 设为逆变
2. **函数属性**：总是逆变
3. **返回值**：总是协变
4. **数组/泛型**：协变
5. **对象属性**：只读属性协变，可变属性不变

## 实际应用

### 1. 事件处理系统

```typescript
interface Event<T> {
  type: string;
  target: T;
}

class UIEvent implements Event<HTMLElement> {
  type: string = "ui";
  target: HTMLElement;
}

// 协变：Event<HTMLElement> 是 Event<Element> 的子类型
function handleEvent(event: Event<Element>) {}

const uiEvent: Event<HTMLElement> = new UIEvent();
handleEvent(uiEvent); // 合法
```

### 2. 函数高阶组件

```typescript
type Mapper<A, B> = (a: A) => B;

// 逆变示例
function contraMap<A, B, C>(f: (b: B) => C, g: (a: A) => B): (a: A) => C {
  return (a: A) => f(g(a));
}

const toString = (n: number) => n.toString();
const toNumber = (s: string) => parseInt(s, 10);

// string -> number -> string
const wrapped = contraMap(toString, toNumber);
console.log(wrapped("123")); // "123"
```

## 变体与类型安全

理解协变和逆变有助于构建更类型安全的系统：

1. **协变**：当你需要从容器中读取时（生产者）
2. **逆变**：当你需要向容器中写入时（消费者）
3. **不变**：当你既需要读又需要写时

这个原则被称为 **"生产者协变，消费者逆变"**（PECS）。

## 常见误区

1. **认为所有泛型都是协变的**：实际上，函数参数是逆变的
2. **忽略 `strictFunctionTypes` 的影响**：开启后会使方法参数检查更严格
3. **混淆数组的协变与安全性**：TypeScript 数组是协变的，但这可能导致运行时错误

```typescript
let dogs: Dog[] = [new Dog()];
let animals: Animal[] = dogs;
animals.push(new Animal()); // 编译通过，但运行时错误！
dogs[1].breed; // 访问不存在的属性
```
