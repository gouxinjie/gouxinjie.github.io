# TypeScript 类型守卫解析

`类型守卫（Type Guards）是 TypeScript `中一项强大的特性，它允许开发者在代码执行过程中缩小变量的类型范围，从而获得更精确的类型推断。

## 一、类型守卫基础概念

### 1.1 什么是类型守卫

类型守卫是 `TypeScript` 用于在条件分支中缩小变量类型范围的机制，通过特定的语法结构让编译器能够推导出更精确的类型信息。其核心价值在于提升代码类型安全性，同时保持开发效率。

与类型断言不同，类型守卫会**实际执行运行时检查**，而不仅仅是告诉编译器"相信我，我知道这个变量的类型"。类型守卫相当于自动的类型断言，当类型守卫无法处理时，才需要手动使用类型断言`as`来缩小类型。

### 1.2 为什么需要类型守卫

考虑以下场景：

```typescript
function process(value: string | number) {
  // 这里value可能是string或number
  // 如何安全地调用特定类型的方法？
}
```

没有类型守卫时，我们只能使用类型断言，这会导致代码冗长且不安全：

```typescript
if ((value as string).length) {
  // ...
} else {
  (value as number).toFixed(2);
}
```

类型守卫提供了更优雅、更安全的解决方案。

## 二、类型守卫的五大实现方式

### 2.1 typeof 类型守卫

`typeof`是最基础的类型守卫，用于判断基本类型：

```typescript
function process(input: string | number) {
  if (typeof input === "string") {
    console.log(input.toUpperCase()); // 自动推导string类型
  } else {
    console.log(input.toFixed(2)); // 推导number类型
  }
}
```

**注意事项**：

- 仅适用于基本类型（string/number/boolean/symbol）
- 对对象类型无效（typeof object 返回'object'）
- 不可用于自定义类型判断

### 2.2 instanceof 类型守卫

`instanceof`用于判断类实例：

```typescript
class Car {
  drive() {}
}
class Truck {
  load() {}
}

function operate(vehicle: Car | Truck) {
  if (vehicle instanceof Car) {
    vehicle.drive();
  } else {
    vehicle.load();
  }
}
```

**适用场景**：

- 类继承体系中的类型判断
- 需要访问类特有方法时
- 框架中处理不同类实例的场景

### 2.3 in 操作符守卫

`in`操作符检查对象是否包含特定属性：

```typescript
interface Admin {
  permissions: string[];
}
interface User {
  email: string;
}

function authorize(person: Admin | User) {
  if ("permissions" in person) {
    logAccess(person.permissions); // Admin类型
  } else {
    sendEmail(person.email); // User类型
  }
}
```

**优势分析**：

- 比类型断言更安全
- 支持接口和对象字面量类型
- 可检测嵌套属性（需注意原型链问题）

### 2.4 字面量类型守卫

适用于联合类型中的字面量值：

```typescript
type Status = "loading" | "success" | "error";

function handleStatus(status: Status) {
  if (status === "loading") {
    showSpinner();
  } else if (status === "success") {
    showData();
  } else {
    showError();
  }
}
```

**优化技巧**：

- 配合联合类型使用效果最佳
- 使用 switch-case 处理多状态更直观
- 优先用 const 枚举管理字面量集合

### 2.5 自定义类型谓词

通过`is`关键字定义类型谓词函数：

```typescript
function isString(value: unknown): value is string {
  return typeof value === "string";
}

const maybeString: unknown = "Hello";
if (isString(maybeString)) {
  console.log(maybeString.toUpperCase());
}
```

**最佳实践**：

- 谓词函数命名使用`isXxx`格式增强可读性
- 复杂判断逻辑应封装在谓词函数中保持代码整洁
- 优先使用`in`操作符进行属性存在性检查

## 三、高级应用场景

### 3.1 复合类型守卫

组合多种判断条件创建复杂守卫：

```typescript
function isStringArray(value: unknown): value is string[] {
  return Array.isArray(value) && value.every((item) => typeof item === "string");
}

function handleArray(input: unknown) {
  if (isStringArray(input)) {
    const uppercased = input.map((s) => s.toUpperCase());
  }
}
```

### 3.2 异步类型守卫

在异步场景下使用类型守卫：

```typescript
async function fetchIsAdmin(userId: string): Promise<boolean> {
  const response = await fetch(`/api/auth/${userId}`);
  const data = await response.json();
  return data.role === "admin";
}

async function handleUser(userId: string) {
  if (await fetchIsAdmin(userId)) {
    // 显示管理员面板
  }
}
```

### 3.3 基于类的类型守卫

在类方法中使用`this`类型谓词：

```typescript
abstract class User {
  name: string;
  isStudent(): this is Student {
    return this instanceof Student;
  }
}

class Student extends User {
  study: string;
}
class Staff extends User {
  workingYears: number;
}

function judgeClassType(obj: User) {
  if (obj.isStudent()) {
    // obj的类型被缩小为Student
  }
}
```

## 四、性能优化与错误规避

### 4.1 性能优化策略

- 对高频操作的类型守卫进行缓存
- 复杂判断逻辑进行预计算
- 优先使用内置类型判断方法
- 避免在循环中执行重类型检查

### 4.2 常见错误规避

**错误谓词函数**：

```typescript
// 错误：未正确实现类型谓词
function isCatBroken(animal: Cat | Dog): boolean {
  return "purr" in animal;
}

// 正确：使用类型谓词声明
function isCat(animal: Cat | Dog): animal is Cat {
  return "purr" in animal;
}
```

**未处理全部分支**：

```typescript
type Shape = Circle | Square;

function getArea(shape: Shape) {
  if ("radius" in shape) {
    return Math.PI * shape.radius ** 2;
  }
  // 错误：缺少Square处理逻辑
}

// 正确：使用穷尽检查
function getAreaSafe(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.size ** 2;
    default:
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}
```
