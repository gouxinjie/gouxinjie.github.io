# TypeScript 泛型

泛型是 `TypeScript` 中最强大的特性之一，它允许我们创建可重用、类型安全的组件。

## 一、泛型基础概念

### 1. 为什么需要泛型？

考虑以下场景：

```typescript
// 非泛型实现 - 需要多个函数
function identityNumber(arg: number): number {
  return arg;
}

function identityString(arg: string): string {
  return arg;
}

// 泛型实现 - 一个函数处理所有类型
function identity<T>(arg: T): T {
  return arg;
}
```

### 2. 基本语法

```typescript
function genericFunc<T>(param: T): T {
  return param;
}

// 调用时显式指定类型
genericFunc<string>("hello");

// 或让TS推断类型
genericFunc("hello"); // TS推断T为string
```

## 二、泛型在不同场景的应用

### 1. 泛型接口

```typescript
interface GenericIdentityFn<T> {
  (arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: GenericIdentityFn<number> = identity;
```

### 2. 泛型类

```typescript
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = (x, y) => x + y;
```

### 3. 泛型约束

```typescript
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length); // 现在知道arg有length属性
  return arg;
}
```

## 三、高级泛型模式

### 1. 使用类型参数

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

let x = { a: 1, b: 2 };
getProperty(x, "a"); // 正确
getProperty(x, "c"); // 错误: "c"不在"a"|"b"中
```

### 2. 泛型与条件类型

```typescript
type IsString<T> = T extends string ? true : false;

type A = IsString<string>; // true
type B = IsString<number>; // false
```

### 3. 映射类型

```typescript
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

type Partial<T> = {
  [P in keyof T]?: T[P];
};
```

## 四、实用泛型工具

### 1. 内置工具类型

```typescript
// 使所有属性可选
type PartialUser = Partial<User>;

// 使所有属性只读
type ReadonlyUser = Readonly<User>;

// 选取部分属性
type UserName = Pick<User, "firstName" | "lastName">;

// 忽略某些属性
type UserWithoutId = Omit<User, "id">;
```

### 2. 自定义实用类型

```typescript
// 提取Promise的返回值类型
type UnpackPromise<T> = T extends Promise<infer U> ? U : T;

// 提取数组元素类型
type ElementType<T> = T extends (infer U)[] ? U : never;
```

## 五、React 中的泛型应用

### 1. 泛型组件

```typescript
interface ListProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
  return <div>{items.map(renderItem)}</div>;
}

// 使用
<List<number> items={[1, 2, 3]} renderItem={(n) => <div>{n}</div>} />;
```

### 2. 泛型 Hooks

```typescript
function useArray<T>(initial: T[]) {
  const [value, setValue] = useState(initial);

  const push = (item: T) => setValue([...value, item]);

  return { value, push };
}

// 使用
const { value, push } = useArray<string>(["a", "b"]);
push("c"); // 正确
push(1); // 错误
```

## 六、最佳实践与常见错误

### 1. 最佳实践

- **命名约定**：使用大写字母（T, U, V）或描述性名称（TKey, TValue）
- **适当约束**：不要过度使用泛型，只在需要灵活性时使用
- **明确文档**：为复杂泛型添加注释说明

### 2. 常见错误

```typescript
// 错误1: 不必要的泛型
function badExample<T>(arg: T[]): number {
  return arg.length;
}
// 应改为:
function goodExample(arg: any[]): number {
  return arg.length;
}

// 错误2: 忽略约束
function firstElement<T>(arr: T[]): T {
  return arr[0]; // 如果数组为空会返回undefined
}
// 改进:
function safeFirstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}
```

## 七、性能考量

1. **编译时特性**：泛型不会影响运行时性能
2. **类型实例化**：过度复杂的泛型可能增加编译时间
3. **缓存策略**：对常用泛型类型使用类型别名

```typescript
// 避免重复复杂类型
type ComplexType<T> = {
  [K in keyof T]: T[K] extends object ? ComplexType<T[K]> : T[K];
};

// 使用时
type MyComplexType = ComplexType<SomeBigInterface>;
```

## 八、泛型在类型体操中的应用

### 1. 递归类型

```typescript
type JsonValue = string | number | boolean | null | JsonValue[] | { [key: string]: JsonValue };
```

### 2. 类型谓词

```typescript
function isArrayOf<T>(arr: unknown, check: (item: unknown) => item is T): arr is T[] {
  return Array.isArray(arr) && arr.every(check);
}
```
