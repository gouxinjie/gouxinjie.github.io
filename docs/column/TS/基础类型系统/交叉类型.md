# TypeScript 交叉类型（Intersection Types）解析

交叉类型是 `TypeScript` 中一种强大的类型组合方式，它允许你将多个类型合并为一个类型，新类型将包含所有原类型的特性。

## 一、交叉类型基础

### 1. 基本语法

```typescript
type A = { a: number };
type B = { b: string };

type C = A & B; // C 同时拥有 a 和 b 属性
```

### 2. 简单示例

```typescript
type Person = {
  name: string;
  age: number;
};

type Employee = {
  id: number;
  department: string;
};

type Staff = Person & Employee;

const staff: Staff = {
  name: "张三",
  age: 30,
  id: 1001,
  department: "研发部"
};
```

## 二、交叉类型的特点

### 1. 类型合并机制

- 对于对象类型：合并所有属性
- 对于原始类型：产生 `never` 类型（如 `string & number`）
- 对于函数类型：参数类型取交叉，返回值类型取联合

### 2. 与联合类型的区别

| 特性     | 交叉类型（&）      | 联合类型             |
| -------- | ------------------ | -------------------- |
| 含义     | 同时满足所有类型   | 满足其中任意一个类型 |
| 属性访问 | 可以访问所有属性   | 只能访问共有属性     |
| 类型关系 | 类型收缩（更具体） | 类型扩展（更宽泛）   |

## 三、高级用法

### 1. 合并多个类型

```typescript
type A = { a: number };
type B = { b: string };
type C = { c: boolean };

type ABC = A & B & C;

const abc: ABC = {
  a: 1,
  b: "text",
  c: true
};
```

### 2. 与泛型结合

```typescript
function merge<T, U>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

const result = merge({ a: 1 }, { b: "2" });
// result 类型为 { a: number } & { b: string }
```

### 3. 函数类型交叉

```typescript
type Func1 = (x: number) => string;
type Func2 = (x: number) => number;

type FuncIntersection = Func1 & Func2;
// 等价于 (x: number) => string & number
// 即 (x: number) => never
```

## 四、实际应用场景

### 1. 扩展第三方库类型

```typescript
// 扩展 window 对象
type WindowWithCustomProps = Window & {
  MY_APP: {
    version: string;
    init: () => void;
  };
};

declare const window: WindowWithCustomProps;
window.MY_APP.init();
```

### 2. React 组件属性组合

```typescript
type BaseProps = {
  className?: string;
  style?: React.CSSProperties;
};

type ButtonProps = {
  onClick: () => void;
  disabled?: boolean;
};

type MyButtonProps = BaseProps & ButtonProps;

const MyButton: React.FC<MyButtonProps> = (props) => {
  /* ... */
};
```

### 3. 混入（Mixin）模式实现

```typescript
class Disposable {
  dispose() {
    console.log("Disposing...");
  }
}

class Activatable {
  activate() {
    console.log("Activating...");
  }
}

type SmartObject = Disposable & Activatable;

function createSmartObject(): SmartObject {
  const result = {} as SmartObject;
  Object.assign(result, new Disposable(), new Activatable());
  return result;
}

const obj = createSmartObject();
obj.activate();
obj.dispose();
```

## 五、特殊情况和注意事项

### 1. 同名属性处理

```typescript
type A = { prop: number };
type B = { prop: string };

type C = A & B;
// prop 的类型为 number & string，即 never

const c: C = { prop: 1 as never }; // 需要类型断言
```

### 2. 与接口继承的区别

| 特性     | 交叉类型     | 接口继承         |
| -------- | ------------ | ---------------- |
| 语法     | `&` 运算符   | `extends` 关键字 |
| 合并冲突 | 产生 `never` | 报错             |
| 声明合并 | 不支持       | 支持             |
| 可读性   | 适合简单组合 | 适合复杂层次结构 |
