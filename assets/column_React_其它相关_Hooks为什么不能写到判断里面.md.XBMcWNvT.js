import{_ as e,C as n,c as t,o,j as a,G as l,aQ as p,a as r}from"./chunks/framework.DEi4YP2n.js";const y=JSON.parse('{"title":"Hooks 为什么不能写到判断里面","description":"","frontmatter":{},"headers":[],"relativePath":"column/React/其它相关/Hooks为什么不能写到判断里面.md","filePath":"column/React/其它相关/Hooks为什么不能写到判断里面.md","lastUpdated":1757409539000}'),h={name:"column/React/其它相关/Hooks为什么不能写到判断里面.md"};function k(d,s,c,g,E,u){const i=n("ArticleMetadata");return o(),t("div",null,[s[0]||(s[0]=a("h1",{id:"hooks-为什么不能写到判断里面",tabindex:"-1"},[r("Hooks 为什么不能写到判断里面 "),a("a",{class:"header-anchor",href:"#hooks-为什么不能写到判断里面","aria-label":'Permalink to "Hooks 为什么不能写到判断里面"'},"​")],-1)),l(i),s[1]||(s[1]=p(`<hr><p>React 钩子函数（Hooks）有一个重要的规则：<strong>不能在条件语句、循环或嵌套函数中调用钩子</strong></p><h2 id="_1-底层原理-hooks-依赖调用顺序" tabindex="-1">1. 底层原理：Hooks 依赖调用顺序 <a class="header-anchor" href="#_1-底层原理-hooks-依赖调用顺序" aria-label="Permalink to &quot;1. 底层原理：Hooks 依赖调用顺序&quot;">​</a></h2><p>React 内部通过 <strong>单向链表</strong> 来管理组件的 Hooks。每次组件渲染时：</p><p>1、React 会按 <strong>Hooks 的调用顺序</strong> 依次执行，并将状态存储在对应的链表节点中。 2、如果 Hook 的调用顺序改变（比如条件判断导致某些 Hook 被跳过），链表节点的匹配会错乱，导致状态错位。</p><p><strong>示例问题代码</strong></p><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (condition) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 条件性调用 Hook</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 无条件 Hook</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>1、<strong>第一次渲染</strong>：<code>condition</code> 为 <code>true</code>，Hook 顺序是 <code>[useState(0), useState(&quot;&quot;)]</code>。<br> 2、<strong>第二次渲染</strong>：<code>condition</code> 为 <code>false</code>，Hook 顺序是 <code>[useState(&quot;&quot;)]</code>（第一个 <code>useState</code> 被跳过）。<br> 3、<strong>结果</strong>：React 会误将 <code>name</code> 的状态关联到原本 <code>count</code> 的链表节点上，导致数据混乱。<br></p><h2 id="_2-react-的规则检查" tabindex="-1">2. React 的规则检查 <a class="header-anchor" href="#_2-react-的规则检查" aria-label="Permalink to &quot;2. React 的规则检查&quot;">​</a></h2><p>React 通过 <strong>ESLint 插件（<code>eslint-plugin-react-hooks</code>）</strong> 在编译时强制检查以下规则：</p><ol><li><strong>所有 Hook 必须在函数组件的顶层调用</strong>（不能嵌套在 <code>if</code>、<code>for</code>、<code>callback</code> 中）。</li><li><strong>Hook 的调用顺序必须一致</strong>（每次渲染时数量、顺序相同）。</li></ol><p>如果违反规则，会抛出类似以下的错误：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">React Hook </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;useState&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> is called conditionally. React Hooks must be called </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the exact same order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> every component render.</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_3-eslint-plugin-react-hooks-插件实现的原理" tabindex="-1">3. eslint-plugin-react-hooks 插件实现的原理 <a class="header-anchor" href="#_3-eslint-plugin-react-hooks-插件实现的原理" aria-label="Permalink to &quot;3. eslint-plugin-react-hooks 插件实现的原理&quot;">​</a></h2><h3 id="_3-1-静态代码分析" tabindex="-1">3.1 静态代码分析 <a class="header-anchor" href="#_3-1-静态代码分析" aria-label="Permalink to &quot;3.1 静态代码分析&quot;">​</a></h3><p>插件通过解析 JavaScript 的 <strong>抽象语法树（AST）</strong> 来检测代码中的 Hook 调用。具体步骤包括：</p><p>1、<strong>识别 Hook 函数名</strong>：检查所有以 <code>use</code> 开头的函数（如 <code>useState</code>、<code>useEffect</code>）是否在合法位置调用。<br> 2、<strong>跟踪调用顺序</strong>：分析 Hook 在组件中的调用顺序是否可能因条件或循环而改变。<br></p><h3 id="_3-2-依赖项数组的静态推导" tabindex="-1">3.2 依赖项数组的静态推导 <a class="header-anchor" href="#_3-2-依赖项数组的静态推导" aria-label="Permalink to &quot;3.2 依赖项数组的静态推导&quot;">​</a></h3><p>对于 <code>useEffect</code>、<code>useMemo</code> 等 Hook 的依赖项数组，插件会：</p><p>1、<strong>收集函数体内引用的变量</strong>：通过 AST 分析，找出所有在 Hook 回调函数中使用的变量（如 <code>props</code>、<code>state</code>、上下文等）68。<br></p><p>2、 <strong>比对依赖项数组</strong>：若变量未包含在依赖项中，则发出警告。例如：<br></p><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(props.value); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ⚠️ 警告：缺少依赖项 props.value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, []);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-3-为什么类组件没有这个限制" tabindex="-1">3.3 为什么类组件没有这个限制？ <a class="header-anchor" href="#_3-3-为什么类组件没有这个限制" aria-label="Permalink to &quot;3.3 为什么类组件没有这个限制？&quot;">​</a></h3><p>类组件的状态（<code>this.state</code>）和生命周期方法是 <strong>通过实例属性存储</strong> 的，与调用顺序无关。而函数组件的 Hooks 是 <strong>通过闭包和链表顺序</strong> 实现的，必须保证稳定性。</p>`,24))])}const m=e(h,[["render",k]]);export{y as __pageData,m as default};
