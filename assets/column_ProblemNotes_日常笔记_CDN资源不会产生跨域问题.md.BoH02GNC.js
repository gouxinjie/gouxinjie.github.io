import{_ as s,C as l,c as a,o as i,j as e,G as n,a2 as r,a as d}from"./chunks/framework.0gGui_5R.js";const f=JSON.parse('{"title":"为什么 CDN 资源不会产生跨域问题","description":"","frontmatter":{},"headers":[],"relativePath":"column/ProblemNotes/日常笔记/CDN资源不会产生跨域问题.md","filePath":"column/ProblemNotes/日常笔记/CDN资源不会产生跨域问题.md","lastUpdated":1763362911000}'),c={name:"column/ProblemNotes/日常笔记/CDN资源不会产生跨域问题.md"};function g(p,t,h,C,u,m){const o=l("ArticleMetadata");return i(),a("div",null,[t[0]||(t[0]=e("h1",{id:"为什么-cdn-资源不会产生跨域问题",tabindex:"-1"},[d("为什么 CDN 资源不会产生跨域问题 "),e("a",{class:"header-anchor",href:"#为什么-cdn-资源不会产生跨域问题","aria-label":'Permalink to "为什么 CDN 资源不会产生跨域问题"'},"​")],-1)),n(o),t[1]||(t[1]=r('<nav class="table-of-contents"><ul><li><a href="#_1-什么情况下才会发生-跨域问题">1. 什么情况下才会发生“跨域问题”？</a></li><li><a href="#_2-常见的-cdn-资源为什么不会触发">2. 常见的 CDN 资源为什么不会触发？</a></li><li><a href="#_3-如何-主动避免-跨域问题-——-cors-机制">3. 如何“主动避免”跨域问题？—— CORS 机制</a></li><li><a href="#总结">总结</a></li></ul></nav><p>这是一个非常经典且重要的前端问题。很多人都有一个误解：“CDN 资源不会产生跨域问题”。</p><p>实际上，更准确的表述是：<strong>我们通过一些技术手段，让 CDN 资源避免了跨域问题。</strong></p><p>核心原因在于 <strong>CDN 资源的域名通常与主站域名不同，但它们被设计成不会触发浏览器的跨域限制</strong>。下面我们从几个层面来深入解析：</p><h3 id="_1-什么情况下才会发生-跨域问题" tabindex="-1">1. 什么情况下才会发生“跨域问题”？ <a class="header-anchor" href="#_1-什么情况下才会发生-跨域问题" aria-label="Permalink to &quot;1. 什么情况下才会发生“跨域问题”？&quot;">​</a></h3><p>首先要明确，跨域问题不是所有请求都会触发。它是<strong>浏览器</strong>出于安全考虑（同源策略）施加的一种限制，只针对某些类型的请求，主要是：</p><ul><li><strong>AJAX / Fetch 请求</strong>：当你使用 <code>XMLHttpRequest</code> 或 <code>Fetch API</code> 去请求不同源的资源时。</li><li><strong>Web 字体</strong>：在 CSS 中通过 <code>@font-face</code> 使用不同源的字体文件。</li><li><strong>Canvas 绘制图片</strong>：在 <code>canvas</code> 上使用 <code>drawImage</code> 绘制不同源的图片，并尝试调用 <code>toDataURL()</code> 或 <code>getImageData()</code> 方法。</li><li><strong>JavaScript 模块</strong>等。</li></ul><h3 id="_2-常见的-cdn-资源为什么不会触发" tabindex="-1">2. 常见的 CDN 资源为什么不会触发？ <a class="header-anchor" href="#_2-常见的-cdn-资源为什么不会触发" aria-label="Permalink to &quot;2. 常见的 CDN 资源为什么不会触发？&quot;">​</a></h3><h4 id="a-脚本资源-script-src" tabindex="-1">a) 脚本资源：<code>&lt;script src=&quot;...&quot;&gt;</code> <a class="header-anchor" href="#a-脚本资源-script-src" aria-label="Permalink to &quot;a) 脚本资源：`&lt;script src=&quot;...&quot;&gt;`&quot;">​</a></h4><ul><li><strong>机制</strong>：HTML 的 <code>&lt;script&gt;</code> 标签天生就<strong>允许跨域</strong>。这是历史原因决定的，也是为了允许像使用公共 CDN 上的 jQuery、Vue 等库。</li><li><strong>背后的逻辑</strong>：浏览器在解析 <code>&lt;script&gt;</code> 时，会去下载并执行其中的代码。这些代码在成功加载后，就在当前页面的执行环境中运行。如果这也有跨域限制，那整个互联网的第三方库生态将无法存在。</li><li><strong>注意</strong>：虽然可以跨域加载，但你可以通过 <code>crossorigin</code> 属性来<strong>有选择地</strong>暴露错误信息。这引出了另一个相关概念。</li></ul><h4 id="b-图片、css、音视频资源-img-link-video" tabindex="-1">b) 图片、CSS、音视频资源：<code>&lt;img&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;video&gt;</code> <a class="header-anchor" href="#b-图片、css、音视频资源-img-link-video" aria-label="Permalink to &quot;b) 图片、CSS、音视频资源：`&lt;img&gt;`, `&lt;link&gt;`, `&lt;video&gt;`&quot;">​</a></h4><ul><li><strong>机制</strong>：这些资源的加载是 <strong>“嵌入”</strong> 而非“请求数据”。它们被浏览器直接渲染或应用，而不需要通过 JavaScript API 去读取其内容。因此，同源策略不会阻止它们的加载。</li><li><strong>举例</strong>：你可以随意在页面上插入一个来自其他域名的图片 <code>&lt;img src=&quot;https://cdn.example.com/cat.jpg&quot;&gt;</code>，浏览器会正常加载和显示。</li></ul><h3 id="_3-如何-主动避免-跨域问题-——-cors-机制" tabindex="-1">3. 如何“主动避免”跨域问题？—— CORS 机制 <a class="header-anchor" href="#_3-如何-主动避免-跨域问题-——-cors-机制" aria-label="Permalink to &quot;3. 如何“主动避免”跨域问题？—— CORS 机制&quot;">​</a></h3><p>对于那些<strong>本来会受到同源策略限制</strong>的请求（如 Web 字体、通过 Fetch 请求 CDN 上的 API），CDN 服务商通过配置 <strong>CORS</strong> 来主动解决这个问题。</p><p><strong>CORS 的工作原理：</strong></p><p>当你的网站 <code>https://www.my-site.com</code> 试图通过 <code>Fetch API</code> 请求 CDN 上的一个资源 <code>https://cdn.example.com/data.json</code> 时，浏览器会执行以下步骤：</p><ol><li><strong>发送请求</strong>：浏览器会正常发送请求。</li><li><strong>浏览器检查</strong>：因为这是跨域请求，浏览器会检查响应头中是否包含一个特定的字段：<code>Access-Control-Allow-Origin</code>。</li><li><strong>CDN 响应</strong>：配置了 CORS 的 CDN 服务器，会在响应头中包含：<div class="language-http vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://www.my-site.com</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>或者，如果 CDN 想允许任何网站访问，它会返回：<div class="language-http vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Access-Control-Allow-Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> *</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><strong>浏览器放行</strong>：浏览器看到响应头中的 <code>Access-Control-Allow-Origin</code> 值包含了你的源站域名（<code>https://www.my-site.com</code>）或通配符<code>*</code>，就会认为这次跨域请求是安全的，从而将响应数据交给你的前端代码。</li></ol><p><strong>CDN 服务商做了什么？</strong> 他们在 CDN 服务器的配置中，为需要跨域访问的资源（如字体、API 接口等）设置了正确的 <code>Access-Control-Allow-Origin</code> 响应头。这就是为什么你可以直接从 CDN 使用 Web 字体，而不会遇到跨域问题。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">资源类型</th><th style="text-align:left;">使用的 HTML 标签/API</th><th style="text-align:left;">为何没有跨域问题</th><th style="text-align:left;">关键原因</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>JavaScript 库</strong></td><td style="text-align:left;"><code>&lt;script src=&quot;...&quot;&gt;</code></td><td style="text-align:left;">历史设计使然，默认允许跨域</td><td style="text-align:left;">浏览器特意放行</td></tr><tr><td style="text-align:left;"><strong>图片、CSS</strong></td><td style="text-align:left;"><code>&lt;img&gt;</code>, <code>&lt;link&gt;</code></td><td style="text-align:left;">属于“嵌入”资源，非同源策略限制对象</td><td style="text-align:left;">浏览器特意放行</td></tr><tr><td style="text-align:left;"><strong>Web 字体</strong></td><td style="text-align:left;"><code>@font-face</code> in CSS</td><td style="text-align:left;">CDN 服务器配置了<strong>CORS</strong>响应头</td><td style="text-align:left;">主动授权</td></tr><tr><td style="text-align:left;"><strong>API 数据</strong></td><td style="text-align:left;"><code>Fetch</code> / <code>AJAX</code></td><td style="text-align:left;">CDN 服务器配置了<strong>CORS</strong>响应头</td><td style="text-align:left;">主动授权</td></tr></tbody></table><p>所以，结论是：</p><ol><li><strong>对于默认就允许跨域的标签（如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>），CDN 资源天然无跨域问题。</strong></li><li><strong>对于默认不允许跨域的请求（如字体、Fetch），CDN 服务商通过正确配置 CORS 响应头，主动告诉浏览器“我允许你跨域访问我”，从而避免了跨域问题。</strong></li></ol><p>这使得 CDN 在作为资源托管和分发的角色时，能够无缝地与任何站点的前端代码协同工作。</p>',23))])}const _=s(c,[["render",g]]);export{f as __pageData,_ as default};
