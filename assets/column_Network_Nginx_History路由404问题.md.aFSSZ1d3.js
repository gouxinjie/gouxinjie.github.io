import{_ as t,C as n,c as e,o as h,j as i,G as l,aQ as p,a as r}from"./chunks/framework.DEi4YP2n.js";const d="/assets/history.DaWe6wf-.png",m=JSON.parse('{"title":"前端hash、history模式的区别及history路由刷新报404问题","description":"","frontmatter":{},"headers":[],"relativePath":"column/Network/Nginx/History路由404问题.md","filePath":"column/Network/Nginx/History路由404问题.md","lastUpdated":1757661311000}'),o={name:"column/Network/Nginx/History路由404问题.md"};function k(c,s,E,g,y,u){const a=n("ArticleMetadata");return h(),e("div",null,[s[0]||(s[0]=i("h1",{id:"前端hash、history模式的区别及history路由刷新报404问题",tabindex:"-1"},[r("前端hash、history模式的区别及history路由刷新报404问题 "),i("a",{class:"header-anchor",href:"#前端hash、history模式的区别及history路由刷新报404问题","aria-label":'Permalink to "前端hash、history模式的区别及history路由刷新报404问题"'},"​")],-1)),l(a),s[1]||(s[1]=p(`<hr><p><strong>目录</strong></p><nav class="table-of-contents"><ul><li><a href="#_1-前端路由原理">1，前端路由原理</a></li><li><a href="#_2-hash模式">2，hash模式</a></li><li><a href="#_3-history模式">3，history模式</a></li><li><a href="#_4-解决刷新404问题">4，解决刷新404问题</a></li><li><a href="#_5-两种路由模式的对比">5，两种路由模式的对比</a></li></ul></nav><h2 id="_1-前端路由原理" tabindex="-1">1，前端路由原理 <a class="header-anchor" href="#_1-前端路由原理" aria-label="Permalink to &quot;1，前端路由原理&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">SPA</p><p>在前端单页面(SPA)中, 只有一个html页面，单纯的浏览器地址改变，不会再去请求新的html网页，而是通过监听路由的变化，并利用JS动态显示和隐藏页面内容来达到类似多个网页的切换效果；</p><p>实现切换的路由模式也分为两种： hash模式 和 history模式</p></div><h2 id="_2-hash模式" tabindex="-1">2，hash模式 <a class="header-anchor" href="#_2-hash模式" aria-label="Permalink to &quot;2，hash模式&quot;">​</a></h2><p><strong>概述：</strong> hash指的是地址中#号以及后面的字符，这个#就是hash符号，中文名哈希符或锚点，哈希符后面的值，我们称之为哈希值；如：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//localhost:31001/#/videoProduce</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//localhost:31001/#/xgplayer</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里的<code>#/videoProduce</code>和<code>#/xgplayer</code>就是hash。</p><p><strong>特点：</strong> hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对请求后端资源完全没有影响，<code>因此改变 hash 不会重新加载页面。</code></p><p>路由的哈希模式其实是利用了window可以监听<code>onhashchange</code>事件，可以实现监听浏览器地址hash值变化，执行相应的js切换网页。这么一来，即使前端并没有发起http请求它也能够找到对应页面的代码块进行按需加载。</p><h2 id="_3-history模式" tabindex="-1">3，history模式 <a class="header-anchor" href="#_3-history模式" aria-label="Permalink to &quot;3，history模式&quot;">​</a></h2><p><strong>概述：</strong> window.history 属性指向 History 对象，它表示当前窗口的浏览历史，更新URL地址不重新发请求。History 对象保存了当前窗口访问过的所有页面网址，它提供的一些方法如下：</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>back()</td><td>该方法转到浏览器会话历史的上一页，与用户单击浏览器的 Back 按钮的行为相同。等价于 <code>history.go(-1)</code>。</td></tr><tr><td>forward()</td><td>该方法转到浏览器会话历史的下一页，与用户单击浏览器的 forward 按钮的行为相同。</td></tr><tr><td>go()</td><td>该方法从会话历史记录中加载特定页面。你可以使用它在历史记录中前后移动，具体取决于你传的参数值。注意：window.history.go()和go(0) 都会重新加载当前页面;</td></tr><tr><td>pushState()</td><td>该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化;</td></tr><tr><td>replaceState()</td><td>该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样;</td></tr></tbody></table><p><strong>弊端</strong>：刷新页面会报404；解决方案如下：</p><h2 id="_4-解决刷新404问题" tabindex="-1">4，解决刷新404问题 <a class="header-anchor" href="#_4-解决刷新404问题" aria-label="Permalink to &quot;4，解决刷新404问题&quot;">​</a></h2><p>我的vue前端项目是使用<code>nginx</code>部署到本地的，当路由模式是hash 模式刷新页面没有任何问题，当是history模式时 刷新页面就会报404错误；</p><p><img src="`+d+`" alt="在这里插入图片描述" loading="lazy"></p><p><strong>history路由模式：</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;history&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  base: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BASE_URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/”</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>原因</strong>：我们使用vue等框架创建的其实是单页面应用，只有一个html页面，路由模式是<code>history时</code> 刷新页面，浏览器会发起一个<code>get</code>请求（见上图右侧部分），请求的路径就是我当前页面刷新的路径：<code>http://localhost/video/videoProduce</code></p><p>我nginx代理的项目路径是<code>/video/</code> 如果直接访问 <code>http://localhost/video/</code>是没有问题的，因为nginx能够匹配到 <code>/video/</code> 并找到alias 目录下面的 index.html文件并运行，也就是启动了前端项目；</p><p>但是我访问的是 <code>/video/videoProduce</code> 它匹配不到 当然就报404了；</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 视频演示项目 http协议</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    alias  </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myProject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deployProject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    index index.html index.htm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>解决方案：</strong></p><p>在nginx 配置添加一行配置： <code>try_files $uri $uri/ /index.html last;</code></p><blockquote><p>解释： 尝试解析下列2个文件/文件夹(自动分辨出，IP后面的路径是文件还是文件夹)， $uri/$uri/; 如果解析到，返回第一个，如果都没有解析到，向127.0.0.1/index.html发起请求跳转(该路由必须真实，不然会报错)</p></blockquote><p>正确写法：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 视频演示项目 http协议</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​    alias  </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myProject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deployProject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​    try_files $uri $uri</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index.html last;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​    index index.html index.htm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>vue 官网给出的解决方案就有这条：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noreferrer">https://router.vuejs.org/zh/guide/essentials/history-mode.html</a></p><h2 id="_5-两种路由模式的对比" tabindex="-1">5，两种路由模式的对比 <a class="header-anchor" href="#_5-两种路由模式的对比" aria-label="Permalink to &quot;5，两种路由模式的对比&quot;">​</a></h2><p>两种路由模式对比如下：</p><table tabindex="0"><thead><tr><th></th><th><strong>hash</strong></th><th><strong>history</strong></th></tr></thead><tbody><tr><td>url显示</td><td>地址中永远带着<code>#</code>，不美观</td><td>地址干净、美观</td></tr><tr><td>页面刷新</td><td>可以加载到hash值对应页面</td><td>可能会出现404 找不到页面</td></tr><tr><td>支持版本</td><td>支持低版本浏览器和IE浏览器</td><td>HTML5新推出的API</td></tr><tr><td>上线部署</td><td>无</td><td>需要设置一下nginx的配置</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>如果用户考虑url的规范那么就需要使用<code>history模式</code>，因为history模式没有#号，是个正常的url适合推广宣传。</li><li>其功能也有区别，比如我们在开发app的时候有分享页面，咱们把这个页面分享到第三方的app里，有的app里面url是不允许带有#号的，会被标记为不合法。所以要将#号去除那么就要使用history模式。</li></ul>`,35))])}const v=t(o,[["render",k]]);export{m as __pageData,v as default};
