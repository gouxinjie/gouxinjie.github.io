import{_ as e,C as n,c as t,o as l,j as i,G as p,a2 as r,a as h}from"./chunks/framework.0gGui_5R.js";const d="/assets/nginx-banner.CO8jEif0.png",o="/assets/history.z3bEhd-X.png",v=JSON.parse('{"title":"前端 hash、history 模式的区别及 history 路由刷新报 404 问题","description":"","frontmatter":{},"headers":[],"relativePath":"column/Nginx/Nginx服务器与部署/History路由404问题.md","filePath":"column/Nginx/Nginx服务器与部署/History路由404问题.md","lastUpdated":1767662060000}'),c={name:"column/Nginx/Nginx服务器与部署/History路由404问题.md"};function k(u,s,g,b,y,m){const a=n("ArticleMetadata");return l(),t("div",null,[s[0]||(s[0]=i("h1",{id:"前端-hash、history-模式的区别及-history-路由刷新报-404-问题",tabindex:"-1"},[h("前端 hash、history 模式的区别及 history 路由刷新报 404 问题 "),i("a",{class:"header-anchor",href:"#前端-hash、history-模式的区别及-history-路由刷新报-404-问题","aria-label":'Permalink to "前端 hash、history 模式的区别及 history 路由刷新报 404 问题"'},"​")],-1)),p(a),s[1]||(s[1]=r('<p><img src="'+d+`" alt="" loading="lazy"></p><nav class="table-of-contents"><ul><li><a href="#_1-前端路由原理">1，前端路由原理</a></li><li><a href="#_2-hash-模式">2，hash 模式</a></li><li><a href="#_3-history-模式">3，history 模式</a></li><li><a href="#_4-解决刷新-404-问题">4，解决刷新 404 问题</a></li><li><a href="#_5-try-file-重定向首页那为什么浏览器地址栏不会改变">5，try_file 重定向首页那为什么浏览器地址栏不会改变？</a><ul><li><a href="#_1-浏览器地址栏的-url-是不会因为返回-index-html-而改变的">1. 浏览器地址栏的 URL 是不会因为返回 index.html 而改变的</a></li><li><a href="#_2-为什么前端路由能在-user-123-下正常显示页面">2. 为什么前端路由能在 /user/123 下正常显示页面？</a></li></ul></li></ul></nav><h2 id="_1-前端路由原理" tabindex="-1">1，前端路由原理 <a class="header-anchor" href="#_1-前端路由原理" aria-label="Permalink to &quot;1，前端路由原理&quot;">​</a></h2><p>在前端单页面(<code>SPA</code>)中, 只有一个 html 页面，单纯的浏览器地址改变，不会再去请求新的 html 网页，而是通过监听路由的变化，并利用 JS 动态显示和隐藏页面内容来达到类似多个网页的切换效果；</p><p>实现切换的路由模式也分为两种：<strong>hash</strong> 模式 和 <strong>history</strong> 模式。</p><p>两种路由模式对比如下：</p><table tabindex="0"><thead><tr><th></th><th><strong>hash</strong></th><th><strong>history</strong></th></tr></thead><tbody><tr><td>url 显示</td><td>地址中永远带着 <code>#</code>，不美观</td><td>地址干净、美观</td></tr><tr><td>页面刷新</td><td>可以加载到 hash 值对应页面</td><td>可能会出现 404 找不到页面</td></tr><tr><td>支持版本</td><td>支持低版本浏览器和 IE 浏览器</td><td>HTML5 新推出的 API</td></tr><tr><td>上线部署</td><td>无需额外配置</td><td>需要设置一下 nginx 的配置</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>如果用户考虑 url 的规范那么就需要使用<code>history模式</code>，因为 history 模式没有#号，是个正常的 url 适合推广宣传。</li><li>其功能也有区别，比如我们在开发 app 的时候有分享页面，咱们把这个页面分享到第三方的 app 里，有的 app 里面 url 是不允许带有#号的，会被标记为不合法。所以要将#号去除那么就要使用 history 模式。</li></ul><h2 id="_2-hash-模式" tabindex="-1">2，hash 模式 <a class="header-anchor" href="#_2-hash-模式" aria-label="Permalink to &quot;2，hash 模式&quot;">​</a></h2><p><strong>概述：</strong> hash 指的是地址中#号以及后面的字符，这个#就是 hash 符号，中文名哈希符或锚点，哈希符后面的值，我们称之为哈希值；如：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//localhost:31001/#/videoProduce</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//localhost:31001/#/xgplayer</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里的<code>#/videoProduce</code>和<code>#/xgplayer</code>就是 hash。</p><p><strong>特点：</strong> hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对请求后端资源完全没有影响，<code>因此改变 hash 不会重新加载页面。</code></p><p>路由的哈希模式其实是利用了 window 可以监听<code>onhashchange</code>事件，可以实现监听浏览器地址 hash 值变化，执行相应的 js 切换网页。这么一来，即使前端并没有发起 http 请求它也能够找到对应页面的代码块进行按需加载。</p><h2 id="_3-history-模式" tabindex="-1">3，history 模式 <a class="header-anchor" href="#_3-history-模式" aria-label="Permalink to &quot;3，history 模式&quot;">​</a></h2><p><code>window.history</code> 属性指向 <code>History</code> 对象，它表示当前窗口的浏览历史，更新 URL 地址不重新发请求。<code>History</code> 对象保存了当前窗口访问过的所有页面网址，它提供的一些方法如下：</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>back()</td><td>该方法转到浏览器会话历史的上一页，与用户单击浏览器的 Back 按钮的行为相同。等价于 <code>history.go(-1)</code>。</td></tr><tr><td>forward()</td><td>该方法转到浏览器会话历史的下一页，与用户单击浏览器的 forward 按钮的行为相同。</td></tr><tr><td>go()</td><td>该方法从会话历史记录中加载特定页面。你可以使用它在历史记录中前后移动，具体取决于你传的参数值。注意：window.history.go()和 go(0) 都会重新加载当前页面;</td></tr><tr><td>pushState()</td><td>该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化;</td></tr><tr><td>replaceState()</td><td>该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样;</td></tr></tbody></table><p><strong>弊端</strong>：刷新页面会报 404；解决方案如下：</p><h2 id="_4-解决刷新-404-问题" tabindex="-1">4，解决刷新 404 问题 <a class="header-anchor" href="#_4-解决刷新-404-问题" aria-label="Permalink to &quot;4，解决刷新 404 问题&quot;">​</a></h2><p>我的 vue 前端项目是使用<code>nginx</code>部署到本地的，当路由模式是 hash 模式刷新页面没有任何问题，当是 history 模式时 刷新页面就会报 404 错误；</p><p>这是典型的<code>SPA</code>页面会出现的一个问题。</p><p><img src="`+o+`" alt="在这里插入图片描述" loading="lazy"></p><p><strong>history 路由模式：</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;history&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  base: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BASE_URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/”</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>原因</strong>：</p><div class="tip custom-block"><p class="custom-block-title">路由刷新为什么会 404？</p><ul><li>地址栏显示 video/videoProduce，但这是前端路由伪造的路径，磁盘上并不存在 video/videoProduce 这样的实体文件。</li><li>浏览器刷新 → 服务器去硬盘找 video/videoProduce → 找不到 → 返回 404。</li><li>CSR（客户端渲染）的通病：只有首页 / 能正常返回 index.html，其他深度路径都会暴毙。</li></ul></div><p>我 nginx 代理的项目路径是<code>/video/</code> 如果直接访问 <code>http://localhost/video/</code>是没有问题的，因为 nginx 能够匹配到 <code>/video/</code> 并找到 alias 目录下面的 index.html 文件并运行，也就是启动了前端项目；</p><p>但是我访问的是 <code>/video/videoProduce</code> 它匹配不到 当然就报 404 了；</p><div class="language-nginx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 视频演示项目</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">location</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> /video/ </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    alias </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> D:/myProject/deployProject/video/;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    index </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index.html index.htm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>解决方案：</strong></p><p>在 nginx 配置添加一行配置： <code>try_files $uri $uri/ /index.html;</code></p><div class="tip custom-block"><p class="custom-block-title">try_files 做了什么</p><p>try_files file1 file2 … fallback;</p><ul><li>按顺序检查文件是否存在：</li></ul><ol><li>$uri → 磁盘真实文件（如 /js/app.123.js、/favicon.ico）</li><li>$uri/ → 目录（可选，一般用于目录索引）</li><li>/index.html → 兜底，前面都没找到就返回它</li></ol><ul><li>返回第一个命中的；若全部失败，内部重写到最后的 fallback。</li></ul></div><p><strong>因此：</strong></p><p>静态资源（JS/CSS/图片）→ 第 1 步就命中，正常返回。<br> 前端路由路径（/user/123）→ 前两项都不存在 → 回退到 index.html → 浏览器拿到入口页 → 前端路由（Vue-Router / React-Router）读取当前 URL → 渲染对应组件 → 页面正常显示，不会 404。</p><p><strong>解决方案：</strong></p><div class="language-nginx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 视频演示项目</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">location</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> /video/ </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> alias </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> D:/myProject/deployProject/video/;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> try_files </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$uri $uri/ /index.html;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> index </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index.html index.htm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 其他文件夹处理 404 问题</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try_files </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$uri $uri/ /yourcatalog/index.html;;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>vue 官网给出的解决方案就有这条：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noreferrer">https://router.vuejs.org/zh/guide/essentials/history-mode.html</a></p><h2 id="_5-try-file-重定向首页那为什么浏览器地址栏不会改变" tabindex="-1">5，try_file 重定向首页那为什么浏览器地址栏不会改变？ <a class="header-anchor" href="#_5-try-file-重定向首页那为什么浏览器地址栏不会改变" aria-label="Permalink to &quot;5，try_file 重定向首页那为什么浏览器地址栏不会改变？&quot;">​</a></h2><p>这是一个 <strong>非常典型、但很多人第一次会困惑的问题</strong>：</p><blockquote><p>使用 <code>try_files $uri /index.html</code>，刷新访问 <code>/user/123</code> 明明会 fallback 到 <code>/index.html</code>， <strong>那为什么浏览器的地址栏仍然显示 <code>/user/123</code>，前端路由页面也正常展示？</strong></p></blockquote><p>答案：<strong>这正是 SPA（单页应用）工作原理的一部分——由前端路由控制页面展示，URL 保持不变。</strong></p><p>下面我用非常清晰的步骤解释：</p><h3 id="_1-浏览器地址栏的-url-是不会因为返回-index-html-而改变的" tabindex="-1">1. 浏览器地址栏的 URL 是不会因为返回 index.html 而改变的 <a class="header-anchor" href="#_1-浏览器地址栏的-url-是不会因为返回-index-html-而改变的" aria-label="Permalink to &quot;1. 浏览器地址栏的 URL 是不会因为返回 index.html 而改变的&quot;">​</a></h3><p>你访问：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>https://example.com/user/123</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>刷新时，浏览器发起真实的 HTTP 请求：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>GET /user/123</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后 nginx 执行你的配置：</p><div class="language-nginx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">location</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> / </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try_files </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">$uri /index.html;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>流程是：</p><ol><li>检查 <code>/user/123</code> 是否存在 → ❌ 没有这个文件</li><li>fallback → 返回 <code>/index.html</code> → ✔ 发送给浏览器</li></ol><p>📌 <strong>注意：返回 index.html 只是“响应内容”，不是“重定向”。</strong> 也就是说：</p><p>🎯 <strong>服务器返回了 index.html，但是浏览器地址栏不会改成 /index.html</strong> 🎯 <strong>URL 保持 /user/123 不变，这才是 SPA 的特性</strong></p><h3 id="_2-为什么前端路由能在-user-123-下正常显示页面" tabindex="-1">2. 为什么前端路由能在 <code>/user/123</code> 下正常显示页面？ <a class="header-anchor" href="#_2-为什么前端路由能在-user-123-下正常显示页面" aria-label="Permalink to &quot;2. 为什么前端路由能在 \`/user/123\` 下正常显示页面？&quot;">​</a></h3><p>因为 index.html 只是入口文件，里面会加载你的前端 JS：</p><p>例如：</p><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/assets/index.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>而这个 JS（Vue Router / React Router / etc）会：</p><ol><li>读取当前浏览器 URL（仍然是 <code>/user/123</code>）</li><li>根据 URL 匹配对应的前端路由</li><li>渲染正确的页面组件</li><li>不需要服务器参与</li></ol><p>👉 <strong>前端接管了路由解析，所以页面显示正确的内容。</strong></p>`,61))])}const x=e(c,[["render",k]]);export{v as __pageData,x as default};
