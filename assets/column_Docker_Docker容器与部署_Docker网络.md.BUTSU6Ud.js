import{_ as n,C as i,c as e,o as r,j as a,G as l,aQ as p,a as d}from"./chunks/framework.DEi4YP2n.js";const h="/assets/docker-network.zZ0xKGB7.png",m=JSON.parse('{"title":"Docker 网络：默认三大模式","description":"","frontmatter":{},"headers":[],"relativePath":"column/Docker/Docker容器与部署/Docker网络.md","filePath":"column/Docker/Docker容器与部署/Docker网络.md","lastUpdated":1766732506000}'),o={name:"column/Docker/Docker容器与部署/Docker网络.md"};function k(c,s,g,b,F,u){const t=i("ArticleMetadata");return r(),e("div",null,[s[0]||(s[0]=a("h1",{id:"docker-网络-默认三大模式",tabindex:"-1"},[d("Docker 网络：默认三大模式 "),a("a",{class:"header-anchor",href:"#docker-网络-默认三大模式","aria-label":'Permalink to "Docker 网络：默认三大模式"'},"​")],-1)),l(t),s[1]||(s[1]=p('<nav class="table-of-contents"><ul><li><a href="#一、为什么镜像启动后还要-网络">一、为什么镜像启动后还要“网络”？</a></li><li><a href="#二、默认三大模式速览">二、默认三大模式速览</a></li><li><a href="#三、桥接模式-bridge">三、桥接模式（bridge）</a></li><li><a href="#四、主机模式-host">四、主机模式（host）</a></li><li><a href="#五、none-网络">五、none 网络</a></li></ul></nav><p><img src="'+h+`" alt="alt text" loading="lazy"></p><p>想象一下，你有一个包含 Web 服务器、数据库和缓存的微服务应用。这些容器需要相互通信，同时也需要被外部访问。<code>Docker 网络</code>系统就是为了解决这些通信问题而设计的。没有网络，容器就像孤岛一样无法协作。</p><h2 id="一、为什么镜像启动后还要-网络" tabindex="-1">一、为什么镜像启动后还要“网络”？ <a class="header-anchor" href="#一、为什么镜像启动后还要-网络" aria-label="Permalink to &quot;一、为什么镜像启动后还要“网络”？&quot;">​</a></h2><p>容器本质是隔离的进程，<strong>网络栈（网卡、路由、iptables、DNS）也被隔离</strong>。<br><code>Docker</code> 网络负责：</p><ol><li>让容器 <strong>彼此通信</strong>（同一主机、跨主机）</li><li>让容器 <strong>与外部通信</strong>（互联网、宿主机）</li><li>提供 <strong>DNS 发现</strong>（容器名即域名）</li><li>支持 <strong>热插拔</strong>（运行时加端口、换网段）</li></ol><h2 id="二、默认三大模式速览" tabindex="-1">二、默认三大模式速览 <a class="header-anchor" href="#二、默认三大模式速览" aria-label="Permalink to &quot;二、默认三大模式速览&quot;">​</a></h2><table tabindex="0"><thead><tr><th>维度</th><th>bridge（默认）</th><th>host</th><th>none</th></tr></thead><tbody><tr><td>独立 IP</td><td>✅ 有</td><td>❌ 无（=宿主机）</td><td>❌ 无</td></tr><tr><td>端口映射</td><td>需要 <code>-p</code></td><td><strong>不需要</strong></td><td>无意义</td></tr><tr><td>性能</td><td>普通（NAT）</td><td><strong>极高</strong>（零转发）</td><td>无网络</td></tr><tr><td>安全隔离</td><td>默认网络隔离</td><td><strong>与宿主机共享</strong></td><td><strong>完全隔离</strong></td></tr><tr><td>平台支持</td><td>全平台</td><td><strong>仅 Linux 真机</strong></td><td>全平台</td></tr><tr><td>典型用途</td><td>一般业务</td><td>高并发、端口爆炸</td><td>离线、密钥、安全沙箱</td></tr></tbody></table><p>一键体验：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bridge</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          # 默认</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> host</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   nginx</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          # 共享宿主机网络</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> none</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> addr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 空网络</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="三、桥接模式-bridge" tabindex="-1">三、桥接模式（bridge） <a class="header-anchor" href="#三、桥接模式-bridge" aria-label="Permalink to &quot;三、桥接模式（bridge）&quot;">​</a></h2><p>Docker 网络 默认 Bridge（桥接模式），所有的容器都连接到这个网络中，每一个容器都分配了一个内部的 IP 地址，一般都是 172.17 开头。在这个内部子网里面，容器可以通过内部 IP 地址互相访问。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>┌────────────┐            ┌────────────┐</span></span>
<span class="line"><span>│  Container A │            │  Container B │</span></span>
<span class="line"><span>│  eth0@docker0 │────────────▶│  eth0@docker0 │</span></span>
<span class="line"><span>└────────────┘            └────────────┘</span></span>
<span class="line"><span>      ▲                         ▲</span></span>
<span class="line"><span>      │veth                     │veth</span></span>
<span class="line"><span>      └──────── Docker0 (172.17.0.1/16) ─────────┘</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li><strong>docker0</strong> 是 Linux 虚拟网桥，内核自动生成</li><li>每启动一个容器，Docker 创建一对 <strong>veth</strong> 设备（一端在容器，一端插到 docker0）</li><li>容器获得 <strong>172.17.x.x</strong> 地址，同一网段互通；出网流量经宿主机 <strong>iptables MASQUERADE</strong> 规则转发</li></ul><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 创建一个 名叫 network1 的子网</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> network</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> network1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 创建一个 nginx 容器 使用 network1 的子网</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> network1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="四、主机模式-host" tabindex="-1">四、主机模式（host） <a class="header-anchor" href="#四、主机模式-host" aria-label="Permalink to &quot;四、主机模式（host）&quot;">​</a></h2><p>host 模式下，docker 容器直接共享宿主机的网络，容器直接使用宿主机的 IP 地址，无需 -p 参数进行端口映射，容器内的服务直接运行在宿主机的端口上，通过宿主机的 IP 和端口就能访问到容器中服务。</p><p><strong>容器放弃独立网络栈，直接蹭宿主机网</strong></p><table tabindex="0"><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td><strong>无隔离</strong></td><td>容器进程看到的 <code>eth0 / 127.0.0.1 / 端口空间</code> = 宿主机本身</td></tr><tr><td><strong>无端口映射</strong></td><td><code>-p 8080:80</code> 变成 <strong>多余</strong>；容器里监听 <code>:80</code> 就是宿主机 <code>:80</code></td></tr><tr><td><strong>性能极高</strong></td><td>省去 veth + iptables 转发，吞吐量接近裸机，延迟低 10-20 µs</td></tr><tr><td><strong>安全风险</strong></td><td>容器可嗅探宿主机全部流量，能绑定 0.0.0.0 抢占端口</td></tr><tr><td><strong>平台差异</strong></td><td><strong>Windows / Mac 不可用</strong>（Docker Desktop 基于 VM，host 指 VM 而非物理机）</td></tr></tbody></table><p><strong>一键体验</strong></p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> host</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nicolaka/netshoot</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 在容器里</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> addr</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">              # 就是宿主机的网卡列表</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">netstat</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -tunlp</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">       # 能看到宿主机所有监听端口</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>适用场景</strong></p><ul><li>高并发网关、日志采集、Prometheus NodeExporter 等“对性能极度敏感”服务</li><li>需要绑定大量随机端口（ActiveMQ、FTP）时避免映射爆炸</li><li><strong>仅限 Linux 生产节点</strong>，且受信任镜像。</li></ul><h2 id="五、none-网络" tabindex="-1">五、none 网络 <a class="header-anchor" href="#五、none-网络" aria-label="Permalink to &quot;五、none 网络&quot;">​</a></h2><p><strong>容器被拔网线，这个模式表示不联网</strong></p><table tabindex="0"><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td><strong>零网络</strong></td><td>容器内只有 <code>lo</code> 回环接口，无 IP、无路由、无 DNS</td></tr><tr><td><strong>攻击面最小</strong></td><td>即使应用被 RCE，也无法外联、无法横向移动</td></tr><tr><td><strong>日志 / sidecar 通过卷或 stdout 输出</strong></td><td>常与 <code>docker logs</code> 或文件卷配合</td></tr><tr><td><strong>体积最小</strong></td><td>镜像构建阶段无网络依赖时，可确保“离线纯净”</td></tr></tbody></table><p><strong>一键体验</strong></p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --rm</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --network</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> none</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> alpine</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sh</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;ip addr; ping 8.8.8.8&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 只能看到 lo，ping 提示 Network unreachable</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>适用场景</strong></p><ul><li>离线加密运算、签名机、密钥管理——“绝不让数据出容器”</li><li>调试网络无关代码（纯算法、正则测试）</li><li>CI 安全阶段：确保构建过程 <strong>不偷偷下载依赖</strong>。</li></ul>`,30))])}const y=n(o,[["render",k]]);export{m as __pageData,y as default};
