import{_ as n,C as t,c as l,o as e,j as i,G as p,aQ as h,a as r}from"./chunks/framework.DEi4YP2n.js";const y=JSON.parse('{"title":"MySQL 中的连接方式及其优缺点","description":"","frontmatter":{},"headers":[],"relativePath":"column/Node/MySQL/JOIN连接操作.md","filePath":"column/Node/MySQL/JOIN连接操作.md","lastUpdated":1760403902000}'),k={name:"column/Node/MySQL/JOIN连接操作.md"};function o(d,s,g,E,c,u){const a=t("ArticleMetadata");return e(),l("div",null,[s[0]||(s[0]=i("h1",{id:"mysql-中的连接方式及其优缺点",tabindex:"-1"},[r("MySQL 中的连接方式及其优缺点 "),i("a",{class:"header-anchor",href:"#mysql-中的连接方式及其优缺点","aria-label":'Permalink to "MySQL 中的连接方式及其优缺点"'},"​")],-1)),p(a),s[1]||(s[1]=h(`<nav class="table-of-contents"><ul><li><a href="#_1-内连接-inner-join">1. 内连接（INNER JOIN）</a></li><li><a href="#_2-左连接-left-join">2. 左连接（LEFT JOIN）</a></li><li><a href="#_3-右连接-right-join">3. 右连接（RIGHT JOIN）</a></li><li><a href="#_4-全连接-full-join">4. 全连接（FULL JOIN）</a></li><li><a href="#_5-交叉连接-cross-join">5. 交叉连接（CROSS JOIN）</a></li><li><a href="#_6-自连接-self-join">6. 自连接（SELF JOIN）</a><ul><li><a href="#总结">总结</a></li></ul></li></ul></nav><p>在数据库查询中，<strong>连接</strong>（JOIN）操作是非常常见且重要的，它用于将多个表的数据组合在一起。MySQL 提供了多种不同类型的连接方式，每种连接方式有其独特的适用场景、优点和缺点。了解这些连接方式的区别，可以帮助你在编写查询时做出更合适的选择，从而提高数据库查询效率和性能。</p><h2 id="_1-内连接-inner-join" tabindex="-1">1. 内连接（INNER JOIN） <a class="header-anchor" href="#_1-内连接-inner-join" aria-label="Permalink to &quot;1. 内连接（INNER JOIN）&quot;">​</a></h2><p><strong>内连接</strong>是最常用的连接方式，它只返回在两个表中都满足连接条件的行。如果某个表中的某行在另一个表中没有匹配的行，那么这行数据不会出现在结果中。</p><p><strong>语法：</strong></p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> columns</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INNER JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>优点：</strong></p><ul><li><strong>速度较快</strong>：因为只返回匹配的行，减少了不必要的查询和计算。</li><li><strong>易于理解和使用</strong>：内连接是最常见的连接方式，语法简洁，适用于大多数查询场景。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>丢失未匹配的数据</strong>：如果某些行在连接条件下没有匹配的行，这些行就不会出现在结果中。</li></ul><p><strong>使用场景：</strong></p><p>内连接适用于查找两个表中满足条件的匹配记录。例如，查询订单和客户信息时，只想要那些有订单记录的客户数据。</p><h2 id="_2-左连接-left-join" tabindex="-1">2. 左连接（LEFT JOIN） <a class="header-anchor" href="#_2-左连接-left-join" aria-label="Permalink to &quot;2. 左连接（LEFT JOIN）&quot;">​</a></h2><p><strong>左连接</strong>（或左外连接，LEFT OUTER JOIN）返回左表中的所有记录和右表中满足连接条件的记录。如果右表没有匹配的行，则返回 <code>NULL</code>。</p><p><strong>语法</strong>：</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> columns</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LEFT JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>优点</strong>：</p><ul><li><strong>保留左表所有数据</strong>：即使右表没有匹配的行，左表的数据仍然会被返回。</li><li><strong>适用于查找“无匹配”情况</strong>：对于某些需要确保左表所有记录都被显示的场景（例如获取所有客户信息，即使他们没有订单），左连接是必需的。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>结果可能包含 <code>NULL</code> 值</strong>：如果右表中没有匹配的行，返回的结果会包含 <code>NULL</code>，有时这会增加处理的复杂性。</li><li><strong>性能较差</strong>：相较于内连接，左连接可能需要处理更多的数据，因此性能会略微下降。</li></ul><p><strong>使用场景</strong>：</p><p>左连接适用于需要返回左表所有数据的查询，比如获取所有员工信息以及他们可能的部门信息，即使有些员工没有对应的部门。</p><h2 id="_3-右连接-right-join" tabindex="-1">3. 右连接（RIGHT JOIN） <a class="header-anchor" href="#_3-右连接-right-join" aria-label="Permalink to &quot;3. 右连接（RIGHT JOIN）&quot;">​</a></h2><p><strong>右连接</strong>（或右外连接，RIGHT OUTER JOIN）与左连接相似，不同的是它返回右表中的所有记录和左表中满足连接条件的记录。如果左表没有匹配的行，则返回 <code>NULL</code>。</p><p><strong>语法：</strong></p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> columns</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RIGHT JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>优点：</strong></p><ul><li><strong>保留右表所有数据</strong>：即使左表没有匹配的行，右表的数据仍然会被返回。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>结果可能包含 <code>NULL</code> 值</strong>：如果左表没有匹配的行，返回的结果会包含 <code>NULL</code>。</li><li><strong>性能较差</strong>：相比左连接，右连接可能需要处理更多的右表数据，导致性能下降。</li></ul><p><strong>使用场景：</strong></p><p>右连接适用于需要返回右表所有数据的查询，类似于左连接，但左表中某些数据缺失时，右表数据仍然需要被显示。例如，在获取某个项目的所有任务时，可能希望确保所有任务（即使没有分配给某个员工）都被显示。</p><h2 id="_4-全连接-full-join" tabindex="-1">4. 全连接（FULL JOIN） <a class="header-anchor" href="#_4-全连接-full-join" aria-label="Permalink to &quot;4. 全连接（FULL JOIN）&quot;">​</a></h2><p><strong>全连接</strong>（或全外连接，FULL OUTER JOIN）返回两个表中所有的行，满足连接条件的行会连接在一起，如果某个表没有匹配的行，则返回 <code>NULL</code>。</p><p>MySQL 本身不直接支持 <strong>FULL JOIN</strong>，但可以通过联合 <code>LEFT JOIN</code> 和 <code>RIGHT JOIN</code> 来模拟实现。</p><p><strong>语法：</strong></p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> columns</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">LEFT JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UNION</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> columns</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RIGHT JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> table2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>优点：</strong></p><ul><li><strong>返回两个表的所有数据</strong>：即使某个表的行没有匹配，另一个表的数据仍会被返回。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>复杂性较高</strong>：MySQL 不原生支持 <code>FULL JOIN</code>，需要通过 <code>UNION</code> 来模拟，查询变得复杂且性能较差。</li><li><strong>可能导致冗余数据</strong>：<code>UNION</code> 可能会去重，导致部分数据被过滤，使用时需要谨慎。</li></ul><p><strong>使用场景：</strong></p><p>全连接适用于需要确保两个表的所有数据都被显示的场景。比如，在处理客户与订单数据时，可能希望查看所有客户和所有订单，包括那些没有下单的客户和没有客户的订单。</p><h2 id="_5-交叉连接-cross-join" tabindex="-1">5. 交叉连接（CROSS JOIN） <a class="header-anchor" href="#_5-交叉连接-cross-join" aria-label="Permalink to &quot;5. 交叉连接（CROSS JOIN）&quot;">​</a></h2><p><strong>交叉连接</strong>返回两个表的笛卡尔积，即每一行左表的记录都会与右表的每一行结合。结果集的行数等于左表的行数乘以右表的行数。</p><p><strong>语法：</strong></p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> columns</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">CROSS JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table2;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>优点：</strong></p><ul><li><strong>简单直接</strong>：适用于生成所有可能的组合，特别是在需要创建所有可能组合的场景下。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>结果集庞大</strong>：如果两个表的数据量很大，笛卡尔积的结果集可能会非常庞大，导致性能问题。</li><li><strong>通常不常用</strong>：由于结果集非常大且没有过滤条件，交叉连接通常不常用。</li></ul><p><strong>使用场景：</strong></p><p>交叉连接常用于生成数据的所有组合。例如，在进行模拟、测试或者产品定价时，可能需要生成所有可能的组合。</p><h2 id="_6-自连接-self-join" tabindex="-1">6. 自连接（SELF JOIN） <a class="header-anchor" href="#_6-自连接-self-join" aria-label="Permalink to &quot;6. 自连接（SELF JOIN）&quot;">​</a></h2><p><strong>自连接</strong>是一个表与自身进行连接，通常用于查询表中的层级关系或关联记录。例如，员工表与其经理之间的关系。</p><p><strong>语法：</strong></p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">columns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">columns</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">FROM</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">JOIN</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ON</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>优点：</strong></p><ul><li><strong>灵活性高</strong>：适用于查询表内存在层级关系的数据（例如员工与经理的关系）。</li><li><strong>可以减少多表查询</strong>：无需多个表之间的连接，能够在一个表内实现关联查询。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>查询复杂性增加</strong>：可能会导致查询语句变得复杂，尤其是在表数据量较大的情况下，性能可能受到影响。</li></ul><p><strong>使用场景：</strong></p><p>自连接适用于需要表内数据之间关联的查询场景，例如员工表中的员工与经理之间的关系。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><table tabindex="0"><thead><tr><th>连接方式</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>INNER JOIN</strong></td><td>简单、高效，返回匹配的结果</td><td>无匹配的行不返回，可能丢失数据</td></tr><tr><td><strong>LEFT JOIN</strong></td><td>保证返回左表所有数据，即使右表没有匹配</td><td>可能返回大量的 <code>NULL</code>，性能稍差</td></tr><tr><td><strong>RIGHT JOIN</strong></td><td>保证返回右表所有数据，即使左表没有匹配</td><td>可能返回大量的 <code>NULL</code>，性能稍差</td></tr><tr><td><strong>FULL JOIN</strong></td><td>返回两个表的所有数据</td><td>MySQL 不支持，需用 <code>UNION</code>，性能差</td></tr><tr><td><strong>CROSS JOIN</strong></td><td>生成所有组合，简单</td><td>返回非常庞大的结果集，性能差</td></tr><tr><td><strong>SELF JOIN</strong></td><td>用于表与自身的连接，灵活性高</td><td>可能导致复杂的查询，性能问题</td></tr></tbody></table>`,65))])}const F=n(k,[["render",o]]);export{y as __pageData,F as default};
