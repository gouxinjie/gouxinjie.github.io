import{_ as e,C as n,c as t,o as l,j as a,G as p,aQ as h,a as r}from"./chunks/framework.DEi4YP2n.js";const y=JSON.parse('{"title":"toRefs：将响应式对象转换为普通对象，每个属性都是 ref","description":"","frontmatter":{},"headers":[],"relativePath":"column/Vue/响应式API进阶/toRefs.md","filePath":"column/Vue/响应式API进阶/toRefs.md","lastUpdated":1766554620000}'),k={name:"column/Vue/响应式API进阶/toRefs.md"};function o(d,s,c,E,g,u){const i=n("ArticleMetadata");return l(),t("div",null,[s[0]||(s[0]=a("h1",{id:"torefs-将响应式对象转换为普通对象-每个属性都是-ref",tabindex:"-1"},[r("toRefs：将响应式对象转换为普通对象，每个属性都是 ref "),a("a",{class:"header-anchor",href:"#torefs-将响应式对象转换为普通对象-每个属性都是-ref","aria-label":'Permalink to "toRefs：将响应式对象转换为普通对象，每个属性都是 ref"'},"​")],-1)),p(i),s[1]||(s[1]=h(`<nav class="table-of-contents"><ul><li><a href="#_1-介绍">1. 介绍</a></li><li><a href="#_2-为什么-torefs-可以解决解构响应式对象的问题">2. 为什么 toRefs 可以解决解构响应式对象的问题</a><ul><li><a href="#_1-vue-3-响应式系统的工作原理">1. Vue 3 响应式系统的工作原理</a></li><li><a href="#_2-解构响应式对象时丧失响应性">2. 解构响应式对象时丧失响应性</a></li><li><a href="#_3-torefs-的作用">3. toRefs 的作用</a></li><li><a href="#_4-为什么-torefs-可以保持响应性">4. 为什么 toRefs 可以保持响应性</a></li></ul></li></ul></nav><h2 id="_1-介绍" tabindex="-1">1. 介绍 <a class="header-anchor" href="#_1-介绍" aria-label="Permalink to &quot;1. 介绍&quot;">​</a></h2><p>在 Vue 3 中，<code>toRefs</code> 是一个非常有用的 API，它可以将一个响应式对象中的属性转换为 <strong>单独的响应式引用</strong>。这使得我们可以将一个响应式对象的属性解构出来，并且依然保持响应式特性。</p><p>通常情况下，当我们使用 <code>reactive</code> 来创建响应式对象时，我们会遇到 <strong>解构</strong> 的问题——如果直接解构对象的属性，那么解构出来的属性就不再是响应式的了。<code>toRefs</code> 解决了这个问题，它可以让你在解构时保持属性的响应性。</p><p><strong>语法</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { toRefs } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Vue&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toRefs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 toRefs 保持响应式</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_2-为什么-torefs-可以解决解构响应式对象的问题" tabindex="-1">2. 为什么 toRefs 可以解决解构响应式对象的问题 <a class="header-anchor" href="#_2-为什么-torefs-可以解决解构响应式对象的问题" aria-label="Permalink to &quot;2. 为什么 toRefs 可以解决解构响应式对象的问题&quot;">​</a></h2><h3 id="_1-vue-3-响应式系统的工作原理" tabindex="-1">1. Vue 3 响应式系统的工作原理 <a class="header-anchor" href="#_1-vue-3-响应式系统的工作原理" aria-label="Permalink to &quot;1. Vue 3 响应式系统的工作原理&quot;">​</a></h3><p>Vue 3 使用了 <strong><code>Proxy</code></strong> 来处理响应式数据。这个 Proxy 对象会拦截对数据的所有访问和修改操作，并自动追踪依赖。当你修改响应式对象的属性时，Vue 会知道这个属性的变化并自动更新视图。</p><p>例如，以下是一个简单的响应式对象：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Vue&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>state</code> 是一个 <strong>响应式对象</strong>，对其属性的任何修改都会自动触发视图更新。</p><h3 id="_2-解构响应式对象时丧失响应性" tabindex="-1">2. 解构响应式对象时丧失响应性 <a class="header-anchor" href="#_2-解构响应式对象时丧失响应性" aria-label="Permalink to &quot;2. 解构响应式对象时丧失响应性&quot;">​</a></h3><p>当你直接解构响应式对象时，解构出来的变量 <strong>不再是响应式的</strong>，而是普通的 JavaScript 变量。这是因为解构操作会导致对象的 <strong>属性</strong> 直接脱离原始的 <code>Proxy</code> 对象，从而不再受到 Vue 的响应式系统的控制。</p><p>例如：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> state; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接解构</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这段代码中，<code>count</code> 和 <code>name</code> 不再是响应式的，它们只是普通的变量。这意味着它们不再能自动更新视图。如果你修改了 <code>count</code>，视图不会更新。</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接修改，不会触发视图更新</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_3-torefs-的作用" tabindex="-1">3. <code>toRefs</code> 的作用 <a class="header-anchor" href="#_3-torefs-的作用" aria-label="Permalink to &quot;3. \`toRefs\` 的作用&quot;">​</a></h3><p><code>toRefs</code> 实现的关键是将每个对象属性转化为 <code>ref</code>，而 <code>ref</code> 本身是一个 <strong>响应式容器</strong>，它能保持 <code>.value</code> 的响应性特性。通过 <code>ref</code> 对象访问数据时，会自动追踪依赖并触发视图更新。</p><h4 id="示例-使用-torefs-保持解构后的响应性" tabindex="-1">示例：使用 <code>toRefs</code> 保持解构后的响应性 <a class="header-anchor" href="#示例-使用-torefs-保持解构后的响应性" aria-label="Permalink to &quot;示例：使用 \`toRefs\` 保持解构后的响应性&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { reactive, toRefs } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> state</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> reactive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  count: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Vue&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> toRefs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改 count 会触发视图更新</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个例子中，<code>toRefs(state)</code> 返回了一个包含 <code>ref</code> 的对象。每个属性都变成了独立的 <code>ref</code>，因此它们仍然是响应式的，修改它们会自动触发视图更新。</p><h3 id="_4-为什么-torefs-可以保持响应性" tabindex="-1">4. 为什么 <code>toRefs</code> 可以保持响应性 <a class="header-anchor" href="#_4-为什么-torefs-可以保持响应性" aria-label="Permalink to &quot;4. 为什么 \`toRefs\` 可以保持响应性&quot;">​</a></h3><ul><li><strong><code>reactive</code></strong> 使对象的所有属性都变成了 <strong>深度响应式</strong>，每个属性都受 Vue 的响应式系统的管理。</li><li><strong><code>toRefs</code></strong> 的作用是 <strong>将对象的每个属性都转换为单独的 <code>ref</code></strong>。由于 <code>ref</code> 本身是响应式的，它会自动收集依赖并触发更新。</li><li><strong><code>ref</code> 的特性</strong>：<code>ref</code> 会保持对 <code>.value</code> 的响应式处理，因此当解构对象的属性时，Vue 会继续追踪这些属性的变化，并确保视图更新。</li></ul>`,25))])}const m=e(k,[["render",o]]);export{y as __pageData,m as default};
