import{_ as t,C as e,c as n,o as l,j as i,G as h,aQ as p,a as r}from"./chunks/framework.DEi4YP2n.js";const d="/assets/history.DaWe6wf-.png",m=JSON.parse('{"title":"前端 hash、history 模式的区别及 history 路由刷新报 404 问题","description":"","frontmatter":{},"headers":[],"relativePath":"column/Network/Nginx/History路由404问题.md","filePath":"column/Network/Nginx/History路由404问题.md","lastUpdated":1759115073000}'),o={name:"column/Network/Nginx/History路由404问题.md"};function k(c,s,E,g,y,u){const a=e("ArticleMetadata");return l(),n("div",null,[s[0]||(s[0]=i("h1",{id:"前端-hash、history-模式的区别及-history-路由刷新报-404-问题",tabindex:"-1"},[r("前端 hash、history 模式的区别及 history 路由刷新报 404 问题 "),i("a",{class:"header-anchor",href:"#前端-hash、history-模式的区别及-history-路由刷新报-404-问题","aria-label":'Permalink to "前端 hash、history 模式的区别及 history 路由刷新报 404 问题"'},"​")],-1)),h(a),s[1]||(s[1]=p(`<nav class="table-of-contents"><ul><li><a href="#_1-前端路由原理">1，前端路由原理</a></li><li><a href="#_2-hash-模式">2，hash 模式</a></li><li><a href="#_3-history-模式">3，history 模式</a></li><li><a href="#_4-解决刷新-404-问题">4，解决刷新 404 问题</a></li><li><a href="#_5-两种路由模式的对比">5，两种路由模式的对比</a></li></ul></nav><h2 id="_1-前端路由原理" tabindex="-1">1，前端路由原理 <a class="header-anchor" href="#_1-前端路由原理" aria-label="Permalink to &quot;1，前端路由原理&quot;">​</a></h2><p>在前端单页面(SPA)中, 只有一个 html 页面，单纯的浏览器地址改变，不会再去请求新的 html 网页，而是通过监听路由的变化，并利用 JS 动态显示和隐藏页面内容来达到类似多个网页的切换效果；</p><p>实现切换的路由模式也分为两种：<strong>hash</strong> 模式 和 <strong>history</strong> 模式。</p><h2 id="_2-hash-模式" tabindex="-1">2，hash 模式 <a class="header-anchor" href="#_2-hash-模式" aria-label="Permalink to &quot;2，hash 模式&quot;">​</a></h2><p><strong>概述：</strong> hash 指的是地址中#号以及后面的字符，这个#就是 hash 符号，中文名哈希符或锚点，哈希符后面的值，我们称之为哈希值；如：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//localhost:31001/#/videoProduce</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//localhost:31001/#/xgplayer</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这里的<code>#/videoProduce</code>和<code>#/xgplayer</code>就是 hash。</p><p><strong>特点：</strong> hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对请求后端资源完全没有影响，<code>因此改变 hash 不会重新加载页面。</code></p><p>路由的哈希模式其实是利用了 window 可以监听<code>onhashchange</code>事件，可以实现监听浏览器地址 hash 值变化，执行相应的 js 切换网页。这么一来，即使前端并没有发起 http 请求它也能够找到对应页面的代码块进行按需加载。</p><h2 id="_3-history-模式" tabindex="-1">3，history 模式 <a class="header-anchor" href="#_3-history-模式" aria-label="Permalink to &quot;3，history 模式&quot;">​</a></h2><p><code>window.history</code> 属性指向 <code>History</code> 对象，它表示当前窗口的浏览历史，更新 URL 地址不重新发请求。<code>History</code> 对象保存了当前窗口访问过的所有页面网址，它提供的一些方法如下：</p><table tabindex="0"><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>back()</td><td>该方法转到浏览器会话历史的上一页，与用户单击浏览器的 Back 按钮的行为相同。等价于 <code>history.go(-1)</code>。</td></tr><tr><td>forward()</td><td>该方法转到浏览器会话历史的下一页，与用户单击浏览器的 forward 按钮的行为相同。</td></tr><tr><td>go()</td><td>该方法从会话历史记录中加载特定页面。你可以使用它在历史记录中前后移动，具体取决于你传的参数值。注意：window.history.go()和 go(0) 都会重新加载当前页面;</td></tr><tr><td>pushState()</td><td>该方法用于在历史中添加一条记录。pushState()方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有变化;</td></tr><tr><td>replaceState()</td><td>该方法用来修改 History 对象的当前记录，用法与 pushState() 方法一样;</td></tr></tbody></table><p><strong>弊端</strong>：刷新页面会报 404；解决方案如下：</p><h2 id="_4-解决刷新-404-问题" tabindex="-1">4，解决刷新 404 问题 <a class="header-anchor" href="#_4-解决刷新-404-问题" aria-label="Permalink to &quot;4，解决刷新 404 问题&quot;">​</a></h2><p>我的 vue 前端项目是使用<code>nginx</code>部署到本地的，当路由模式是 hash 模式刷新页面没有任何问题，当是 history 模式时 刷新页面就会报 404 错误；</p><p><img src="`+d+`" alt="在这里插入图片描述" loading="lazy"></p><p><strong>history 路由模式：</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> VueRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mode: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;history&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  base: process.env.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BASE_URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/”</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>原因</strong>：</p><div class="tip custom-block"><p class="custom-block-title">路由刷新为什么会 404？</p><ul><li>地址栏显示 video/videoProduce，但这是前端路由伪造的路径，磁盘上并不存在 video/videoProduce 这样的实体文件。</li><li>浏览器刷新 → 服务器去硬盘找 video/videoProduce → 找不到 → 返回 404。</li><li>CSR（客户端渲染）的通病：只有首页 / 能正常返回 index.html，其他深度路径都会暴毙。</li></ul></div><p>我 nginx 代理的项目路径是<code>/video/</code> 如果直接访问 <code>http://localhost/video/</code>是没有问题的，因为 nginx 能够匹配到 <code>/video/</code> 并找到 alias 目录下面的 index.html 文件并运行，也就是启动了前端项目；</p><p>但是我访问的是 <code>/video/videoProduce</code> 它匹配不到 当然就报 404 了；</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 视频演示项目 http协议</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    alias  </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myProject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deployProject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    index index.html index.htm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>解决方案：</strong></p><p>在 nginx 配置添加一行配置： <code>try_files $uri $uri/ /index.html last;</code></p><div class="tip custom-block"><p class="custom-block-title">try_files 做了什么</p><p>try_files file1 file2 … fallback;</p><ul><li>按顺序检查文件是否存在：</li></ul><ol><li>$uri → 磁盘真实文件（如 /js/app.123.js、/favicon.ico）</li><li>$uri/ → 目录（可选，一般用于目录索引）</li><li>/index.html → 兜底，前面都没找到就返回它</li></ol><ul><li>返回第一个命中的；若全部失败，内部重写到最后的 fallback。</li></ul></div><p><strong>因此：</strong></p><p>静态资源（JS/CSS/图片）→ 第 1 步就命中，正常返回。<br> 前端路由路径（/user/123）→ 前两项都不存在 → 回退到 index.html → 浏览器拿到入口页 → 前端路由（Vue-Router / React-Router）读取当前 URL → 渲染对应组件 → 页面正常显示，不会 404。</p><p><strong>解决方案：</strong></p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 视频演示项目 http协议</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">location </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​    alias  </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myProject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">deployProject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">video</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​    try_files $uri $uri</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index.html last;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​    index index.html index.htm;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">​}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>vue 官网给出的解决方案就有这条：<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noreferrer">https://router.vuejs.org/zh/guide/essentials/history-mode.html</a></p><h2 id="_5-两种路由模式的对比" tabindex="-1">5，两种路由模式的对比 <a class="header-anchor" href="#_5-两种路由模式的对比" aria-label="Permalink to &quot;5，两种路由模式的对比&quot;">​</a></h2><p>两种路由模式对比如下：</p><table tabindex="0"><thead><tr><th></th><th><strong>hash</strong></th><th><strong>history</strong></th></tr></thead><tbody><tr><td>url 显示</td><td>地址中永远带着 <code>#</code>，不美观</td><td>地址干净、美观</td></tr><tr><td>页面刷新</td><td>可以加载到 hash 值对应页面</td><td>可能会出现 404 找不到页面</td></tr><tr><td>支持版本</td><td>支持低版本浏览器和 IE 浏览器</td><td>HTML5 新推出的 API</td></tr><tr><td>上线部署</td><td>无需额外配置</td><td>需要设置一下 nginx 的配置</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>如果用户考虑 url 的规范那么就需要使用<code>history模式</code>，因为 history 模式没有#号，是个正常的 url 适合推广宣传。</li><li>其功能也有区别，比如我们在开发 app 的时候有分享页面，咱们把这个页面分享到第三方的 app 里，有的 app 里面 url 是不允许带有#号的，会被标记为不合法。所以要将#号去除那么就要使用 history 模式。</li></ul>`,37))])}const v=t(o,[["render",k]]);export{m as __pageData,v as default};
