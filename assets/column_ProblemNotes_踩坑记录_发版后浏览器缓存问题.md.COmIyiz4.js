import{_ as n,C as e,c as t,o as l,j as a,G as h,aQ as p,a as r}from"./chunks/framework.DEi4YP2n.js";const m=JSON.parse('{"title":"解决发版后手动清除浏览器缓存的问题","description":"","frontmatter":{},"headers":[],"relativePath":"column/ProblemNotes/踩坑记录/发版后浏览器缓存问题.md","filePath":"column/ProblemNotes/踩坑记录/发版后浏览器缓存问题.md","lastUpdated":1759999524000}'),o={name:"column/ProblemNotes/踩坑记录/发版后浏览器缓存问题.md"};function k(d,s,c,g,E,u){const i=e("ArticleMetadata");return l(),t("div",null,[s[0]||(s[0]=a("h1",{id:"解决发版后手动清除浏览器缓存的问题",tabindex:"-1"},[r("解决发版后手动清除浏览器缓存的问题 "),a("a",{class:"header-anchor",href:"#解决发版后手动清除浏览器缓存的问题","aria-label":'Permalink to "解决发版后手动清除浏览器缓存的问题"'},"​")],-1)),h(i),s[1]||(s[1]=p(`<nav class="table-of-contents"><ul><li><a href="#一、为什么会出现缓存问题">一、为什么会出现缓存问题？</a><ul><li><a href="#常见缓存问题">常见缓存问题</a></li></ul></li><li><a href="#二、如何解决浏览器缓存问题">二、如何解决浏览器缓存问题？</a><ul><li><a href="#_1-文件版本化-cache-busting">1. 文件版本化（Cache Busting）</a></li><li><a href="#_2-利用-nginx-配置清除缓存">2. 利用 Nginx 配置清除缓存</a></li><li><a href="#_3-利用-html-meta-标签中的-cache-control">3. 利用 HTML Meta 标签中的 cache-control</a></li></ul></li></ul></nav><blockquote><p>在前端开发中，浏览器缓存是一个常见而棘手的问题。每当我们更新代码并进行发版时，用户的浏览器可能会继续使用缓存中的旧资源，这会导致用户看到过时的页面或出现错误。特别是在 <strong>JavaScript</strong>、<strong>CSS</strong> 或 <strong>HTML</strong> 资源发生变化时，如果缓存没有及时更新，用户体验会大打折扣。</p></blockquote><h2 id="一、为什么会出现缓存问题" tabindex="-1">一、为什么会出现缓存问题？ <a class="header-anchor" href="#一、为什么会出现缓存问题" aria-label="Permalink to &quot;一、为什么会出现缓存问题？&quot;">​</a></h2><p>浏览器使用缓存来加速页面加载，避免每次访问时都重新下载所有资源。缓存的机制可以大大提高性能，但在某些情况下也会导致问题。最常见的问题是 <strong>浏览器缓存了旧的资源</strong>，即便你已经发版并更新了文件，用户仍然会看到缓存中的过期内容。</p><h3 id="常见缓存问题" tabindex="-1">常见缓存问题 <a class="header-anchor" href="#常见缓存问题" aria-label="Permalink to &quot;常见缓存问题&quot;">​</a></h3><ul><li><strong>JavaScript 或 CSS 更新后，页面仍然使用旧文件</strong></li><li><strong>浏览器加载过期的 <code>index.html</code> 文件</strong></li><li><strong>图片或其他静态资源未更新，导致展示错误</strong></li></ul><h2 id="二、如何解决浏览器缓存问题" tabindex="-1">二、如何解决浏览器缓存问题？ <a class="header-anchor" href="#二、如何解决浏览器缓存问题" aria-label="Permalink to &quot;二、如何解决浏览器缓存问题？&quot;">​</a></h2><h3 id="_1-文件版本化-cache-busting" tabindex="-1">1. <strong>文件版本化（Cache Busting）</strong> <a class="header-anchor" href="#_1-文件版本化-cache-busting" aria-label="Permalink to &quot;1. **文件版本化（Cache Busting）**&quot;">​</a></h3><p>最常见的做法是给文件名加上 <strong>版本号</strong> 或 <strong>哈希值</strong>。每当文件内容发生变化时，文件名也会随之变化，从而强制浏览器重新加载新文件，而不是使用缓存中的旧版本。</p><h4 id="实现方式" tabindex="-1">实现方式： <a class="header-anchor" href="#实现方式" aria-label="Permalink to &quot;实现方式：&quot;">​</a></h4><ul><li><strong>JavaScript</strong> 和 <strong>CSS</strong> 文件通常通过在文件名中添加内容哈希来实现版本控制（例如 <code>main.12345.js</code>）。</li><li><strong>前端构建工具</strong>（如 <strong>Webpack</strong>、<strong>Vite</strong> 等）都内置了文件版本化的功能，在构建过程中自动生成带有哈希值的文件名。</li></ul><p><strong>Webpack 配置示例</strong>：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  output: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[name].[contenthash].js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 为每个输出的文件添加 contenthash</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dist&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这种做法可以确保文件一旦更新，浏览器就会自动下载新的文件，而不会缓存旧的版本。</p><h3 id="_2-利用-nginx-配置清除缓存" tabindex="-1">2. 利用 Nginx 配置清除缓存 <a class="header-anchor" href="#_2-利用-nginx-配置清除缓存" aria-label="Permalink to &quot;2. 利用 Nginx 配置清除缓存&quot;">​</a></h3><p>如果你使用 <strong>Nginx</strong> 作为 Web 服务器，你可以通过配置缓存策略来控制哪些资源应该被缓存，哪些资源需要始终重新加载。</p><h4 id="配置方法" tabindex="-1">配置方法： <a class="header-anchor" href="#配置方法" aria-label="Permalink to &quot;配置方法：&quot;">​</a></h4><p>在 Nginx 配置中，为 <code>index.html</code> 文件设置 <strong>不缓存</strong> 的策略，同时为其他静态资源（如 JS、CSS）设置 <strong>长期缓存</strong>。</p><p><strong>Nginx 配置示例</strong>：</p><div class="language-nginx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">nginx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 这是最关键的一步，确保浏览器总是获取最新的入口文件。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> /index.html </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    add_header </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Cache-Control </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;no-cache, no-store, must-revalidate&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    add_header </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Pragma </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;no-cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    add_header </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Expires </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 这些文件通常不带 Hash，但也不常变动，可以设置一个较长的缓存时间。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> location</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ~*</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;"> .(jpg|jpeg|png|gif|ico|svg|woff|woff2|ttf)$ </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    expires </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30d</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    add_header </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Cache-Control </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;public&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>对于 <code>index.html</code> 文件，使用 <code>Cache-Control: no-cache, no-store</code> 确保每次访问时都加载最新版本。</li><li>对于其他静态资源（字体、图片等），在浏览器和 CDN 里安心缓存 30 天，减少重复请求，提升性能。</li></ul><h4 id="解释" tabindex="-1">解释： <a class="header-anchor" href="#解释" aria-label="Permalink to &quot;解释：&quot;">​</a></h4><ul><li><strong><code>no-cache</code></strong>: 强制浏览器每次验证缓存是否过期。</li><li><strong><code>no-store</code></strong>: 完全不缓存内容，每次请求都会重新获取最新文件。</li><li><strong><code>max-age=31536000</code></strong>: 表示静态资源可以缓存一年。</li><li><strong><code>immutable</code></strong>: 资源不可变，意味着资源不会变化，浏览器可以不检查过期。</li></ul><p>这种方法保证了每次访问 <code>index.html</code> 时都能加载最新版本，同时其他资源如 JS、CSS 文件在没有发生变化时会保持长时间缓存，避免不必要的请求。</p><h3 id="_3-利用-html-meta-标签中的-cache-control" tabindex="-1">3. 利用 HTML Meta 标签中的 cache-control <a class="header-anchor" href="#_3-利用-html-meta-标签中的-cache-control" aria-label="Permalink to &quot;3. 利用 HTML Meta 标签中的 cache-control&quot;">​</a></h3><p>通过在 HTML 的<code>&lt;head&gt;</code>部分添加<code> &lt;meta&gt;</code> 标签来控制缓存策略。虽然这种方式不如 Cache-Control 头部灵活和强大，但它也能控制某些页面的缓存行为。</p><h4 id="示例" tabindex="-1">示例： <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例：&quot;">​</a></h4><div class="language-html vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> http-equiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Cache-Control&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;no-cache, no-store, must-revalidate&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> http-equiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Pragma&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;no-cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> http-equiv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Expires&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><div class="warning custom-block"><p class="custom-block-title">注意</p><p>「HTTP 响应头（Response Headers）的优先级 &gt; HTML Meta 标签</p></div><p>没错，<code>meta </code> 标签更像是一种 “建议”，而由服务器（如 Nginx）在 <code>HTTP</code> 响应中返回的 <code> Cache-Control、Expires</code>  等头部信息，才是浏览器必须严格遵守的 “最高指令”。如果 <code>HTTP</code> 响应头没有明确指示不缓存，或者指示了可以缓存，那么浏览器就会愉快地忽略 <code>meta</code> 标签的建议，将 <code> index.html</code>  缓存起来。</p>`,30))])}const y=n(o,[["render",k]]);export{m as __pageData,y as default};
