import{_ as t,C as e,c as r,o as l,j as s,G as i,aQ as o,a as p}from"./chunks/framework.DEi4YP2n.js";const d="/assets/http1.1.DgPS1MaN.png",k=JSON.parse('{"title":"HTTP/1.1 与 HTTP/2：核心区别与性能对比","description":"","frontmatter":{},"headers":[],"relativePath":"column/Network/Web传输/HTTP1.1和HTTP2.md","filePath":"column/Network/Web传输/HTTP1.1和HTTP2.md","lastUpdated":1757494313000}'),c={name:"column/Network/Web传输/HTTP1.1和HTTP2.md"};function h(b,a,g,u,T,m){const n=e("ArticleMetadata");return l(),r("div",null,[a[0]||(a[0]=s("h1",{id:"http-1-1-与-http-2-核心区别与性能对比",tabindex:"-1"},[s("strong",null,"HTTP/1.1 与 HTTP/2：核心区别与性能对比"),p(),s("a",{class:"header-anchor",href:"#http-1-1-与-http-2-核心区别与性能对比","aria-label":'Permalink to "**HTTP/1.1 与 HTTP/2：核心区别与性能对比**"'},"​")],-1)),i(n),a[1]||(a[1]=o(`<p><code>HTTP（HyperText Transfer Protocol）</code>是 <code>Web</code> 通信的基础协议，从 <code>HTTP/1.1</code> 到 <code>HTTP/2</code>，协议经历了重大升级，显著提升了 Web 性能。</p><h2 id="_1-http-1-1-的局限性" tabindex="-1"><strong>1. HTTP/1.1 的局限性</strong> <a class="header-anchor" href="#_1-http-1-1-的局限性" aria-label="Permalink to &quot;**1. HTTP/1.1 的局限性**&quot;">​</a></h2><p><code>HTTP/1.1</code> 于 <code>1999</code> 年发布，虽然稳定，但随着现代 Web 应用的复杂性增加，其性能瓶颈日益明显：</p><h3 id="_1-1-队头阻塞-head-of-line-blocking" tabindex="-1"><strong>1.1 队头阻塞（Head-of-Line Blocking）</strong> <a class="header-anchor" href="#_1-1-队头阻塞-head-of-line-blocking" aria-label="Permalink to &quot;**1.1 队头阻塞（Head-of-Line Blocking）**&quot;">​</a></h3><ul><li>HTTP/1.1 使用<strong>串行请求</strong>，浏览器对同一域名最多允许 <strong>6-8 个并发连接</strong>。</li><li>如果某个请求响应慢，后续请求会被阻塞（即使它们可以更快完成）。</li></ul><h3 id="_1-2-无头部压缩" tabindex="-1"><strong>1.2 无头部压缩</strong> <a class="header-anchor" href="#_1-2-无头部压缩" aria-label="Permalink to &quot;**1.2 无头部压缩**&quot;">​</a></h3><ul><li>每个 HTTP 请求都携带大量重复头部（如 <code>User-Agent</code>、<code>Cookie</code>），导致冗余数据传输。</li></ul><h3 id="_1-3-文本协议" tabindex="-1"><strong>1.3 文本协议</strong> <a class="header-anchor" href="#_1-3-文本协议" aria-label="Permalink to &quot;**1.3 文本协议**&quot;">​</a></h3><ul><li>HTTP/1.1 使用<strong>纯文本格式</strong>，解析效率低，容易出错。</li></ul><h3 id="_1-4-无服务器推送" tabindex="-1"><strong>1.4 无服务器推送</strong> <a class="header-anchor" href="#_1-4-无服务器推送" aria-label="Permalink to &quot;**1.4 无服务器推送**&quot;">​</a></h3><ul><li>服务器无法主动推送资源（如 CSS、JS），必须等待客户端请求。</li></ul><h2 id="_2-http-2-的核心优化" tabindex="-1"><strong>2. HTTP/2 的核心优化</strong> <a class="header-anchor" href="#_2-http-2-的核心优化" aria-label="Permalink to &quot;**2. HTTP/2 的核心优化**&quot;">​</a></h2><p><code>HTTP/2（2015 年发布）</code>在兼容 <code>HTTP/1.1</code> 语义的基础上，大幅优化了传输效率：</p><h3 id="_2-1-二进制分帧-binary-framing" tabindex="-1"><strong>2.1 二进制分帧（Binary Framing）</strong> <a class="header-anchor" href="#_2-1-二进制分帧-binary-framing" aria-label="Permalink to &quot;**2.1 二进制分帧（Binary Framing）**&quot;">​</a></h3><div class="warning custom-block github-alert"><p class="custom-block-title">HTTP/1.1 是纯文本格式传输数据（存在以下问题）解析复杂（需按行读取）</p><p>容易出错（如换行符处理）<br> 无法高效支持多路复用</p></div><ul><li><strong>HTTP/2 采用二进制格式</strong>，取代 <code>HTTP/1.1</code> 的文本格式，解析更高效。</li><li>数据被拆分为<strong>帧（Frame）</strong>，每个帧有类型（HEADERS、DATA 等），支持多路复用。</li></ul><div class="language-plaintext vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>+-----------------------------------------------+</span></span>
<span class="line"><span>| Length (24 bits)                              | → 帧长度</span></span>
<span class="line"><span>+---------------+---------------+---------------+</span></span>
<span class="line"><span>| Type (8 bits)  | Flags (8 bits)               | → 帧类型和标志位</span></span>
<span class="line"><span>+-+-------------+---------------+---------------+</span></span>
<span class="line"><span>| R (1 bit)     | Stream ID (31 bits)           | → 流标识符</span></span>
<span class="line"><span>+---------------+-------------------------------+</span></span>
<span class="line"><span>| Frame Payload (0~16,384 bytes)                | → 帧数据</span></span>
<span class="line"><span>+-----------------------------------------------+</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>关键字段说明：</strong><br> Type：帧类型（如 HEADERS、DATA、SETTINGS）<br> Stream ID：所属流的唯一标识（支持多路复用的关键）<br> Payload：实际传输的数据</p><h3 id="_2-2-多路复用-multiplexing" tabindex="-1"><strong>2.2 多路复用（Multiplexing）</strong> <a class="header-anchor" href="#_2-2-多路复用-multiplexing" aria-label="Permalink to &quot;**2.2 多路复用（Multiplexing）**&quot;">​</a></h3><div class="warning custom-block github-alert"><p class="custom-block-title">HTTP/1.1 的并发限制</p><p>浏览器对同一域名限制 6~8 个 TCP 连接<br> 每个连接只能串行处理请求（队头阻塞）</p></div><div class="important custom-block github-alert"><p class="custom-block-title">HTTP/2 多路复用</p><p><strong>HTTP/2 通过流（Stream）机制实现真正的并行传输 一个 TCP 连接可并行传输多个请求和响应</strong>，彻底解决队头阻塞问题。<br> 单 TCP 连接可承载多个双向流（Stream）<br> 每个流有唯一 Stream ID，可乱序发送帧<br> 接收方通过 Stream ID 重组消息</p></div><p><strong>如图所示：</strong></p><p><img src="`+d+`" alt="" width="80%" loading="lazy"></p><p>不同流的帧可以交替传输;<br> 一个流的阻塞不会影响其他流;</p><h3 id="_2-3-头部压缩-hpack" tabindex="-1"><strong>2.3 头部压缩（HPACK）</strong> <a class="header-anchor" href="#_2-3-头部压缩-hpack" aria-label="Permalink to &quot;**2.3 头部压缩（HPACK）**&quot;">​</a></h3><div class="warning custom-block github-alert"><p class="custom-block-title">HTTP/1.1 头部的问题</p><p>每个请求重复携带相同头部（如 User-Agent、Cookie）<br> 平均头部大小 500~800 字节，实际有效信息占比低</p></div><ul><li>使用 <strong>HPACK 算法</strong> 压缩 HTTP 头部，减少冗余数据（如 <code>User-Agent</code> 只需发送一次）。</li><li>典型场景下，头部大小减少 <strong>50%-90%</strong>。</li></ul><div class="important custom-block github-alert"><p class="custom-block-title">HPACK 压缩原理</p><p><strong>(1) 静态表（Static Table）</strong> 预定义 61 个常见头部字段（如 :method: GET 对应索引 2）<br><strong>(2) 动态表（Dynamic Table）</strong> 在连接过程中动态维护的头部字段表（如自定义 X-Token）<br><strong>(3) 编码方式</strong> 索引表示：直接引用表中的索引（如 :method: GET → 0x82，霍夫曼编码：对字符串进一步压缩</p></div><p><strong>压缩示例：</strong></p><div class="language-plaintext vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>原始头部:</span></span>
<span class="line"><span>  :method: GET</span></span>
<span class="line"><span>  :path: /index.html</span></span>
<span class="line"><span>  user-agent: Mozilla/5.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>压缩后:</span></span>
<span class="line"><span>  0x82 (静态表索引2: GET)</span></span>
<span class="line"><span>  0x85 (静态表索引5: /index.html)</span></span>
<span class="line"><span>  0x40 0x7a (动态表新增user-agent)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="_2-4-服务器推送-server-push" tabindex="-1"><strong>2.4 服务器推送（Server Push）</strong> <a class="header-anchor" href="#_2-4-服务器推送-server-push" aria-label="Permalink to &quot;**2.4 服务器推送（Server Push）**&quot;">​</a></h3><ul><li>服务器可以<strong>主动推送资源</strong>（如 CSS、JS）到客户端缓存，减少额外请求延迟。</li><li>例如：<div class="language-http vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">HTTP/2 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> OK</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Link</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;/style.css&gt;; rel=preload; as=style</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>服务器可同时推送 <code>style.css</code>，而不需等待 HTML 解析后再请求。</li></ul><h3 id="_2-5-流优先级-stream-prioritization" tabindex="-1"><strong>2.5 流优先级（Stream Prioritization）</strong> <a class="header-anchor" href="#_2-5-流优先级-stream-prioritization" aria-label="Permalink to &quot;**2.5 流优先级（Stream Prioritization）**&quot;">​</a></h3><ul><li>客户端可指定请求的优先级（如优先加载 CSS 而非图片），优化渲染性能。</li></ul><h2 id="_3-http-1-1-vs-http-2-对比表" tabindex="-1"><strong>3. HTTP/1.1 vs HTTP/2 对比表</strong> <a class="header-anchor" href="#_3-http-1-1-vs-http-2-对比表" aria-label="Permalink to &quot;**3. HTTP/1.1 vs HTTP/2 对比表**&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>HTTP/1.1</th><th>HTTP/2</th></tr></thead><tbody><tr><td><strong>传输协议</strong></td><td>文本</td><td>二进制</td></tr><tr><td><strong>并发模型</strong></td><td>6-8 个连接/域名（串行）</td><td>单连接多路复用</td></tr><tr><td><strong>头部压缩</strong></td><td>无</td><td>HPACK 压缩</td></tr><tr><td><strong>服务器推送</strong></td><td>不支持</td><td>支持</td></tr><tr><td><strong>队头阻塞</strong></td><td>存在（TCP 层）</td><td>基本解决（QUIC 彻底解决）</td></tr><tr><td><strong>优先级控制</strong></td><td>有限支持（如 <code>&lt;link preload&gt;</code>）</td><td>精细控制（权重依赖树）</td></tr></tbody></table><h2 id="_4-http-2-的实际性能优势" tabindex="-1"><strong>4. HTTP/2 的实际性能优势</strong> <a class="header-anchor" href="#_4-http-2-的实际性能优势" aria-label="Permalink to &quot;**4. HTTP/2 的实际性能优势**&quot;">​</a></h2><h3 id="_4-1-减少延迟" tabindex="-1"><strong>4.1 减少延迟</strong> <a class="header-anchor" href="#_4-1-减少延迟" aria-label="Permalink to &quot;**4.1 减少延迟**&quot;">​</a></h3><ul><li>多路复用 + 头部压缩使页面加载速度提升 <strong>30%-50%</strong>（尤其是高延迟网络）。</li></ul><h3 id="_4-2-降低服务器负载" tabindex="-1"><strong>4.2 降低服务器负载</strong> <a class="header-anchor" href="#_4-2-降低服务器负载" aria-label="Permalink to &quot;**4.2 降低服务器负载**&quot;">​</a></h3><ul><li>单连接替代多连接，减少 TCP 握手和 TLS 协商开销。</li></ul><h3 id="_4-3-更好的移动端体验" tabindex="-1"><strong>4.3 更好的移动端体验</strong> <a class="header-anchor" href="#_4-3-更好的移动端体验" aria-label="Permalink to &quot;**4.3 更好的移动端体验**&quot;">​</a></h3><ul><li>头部压缩节省流量（对蜂窝网络尤为重要）。</li></ul>`,43))])}const _=t(c,[["render",h]]);export{k as __pageData,_ as default};
