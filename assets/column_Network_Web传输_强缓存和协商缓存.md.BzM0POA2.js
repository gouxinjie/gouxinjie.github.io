import{_ as e,c as d,o as a,aP as o}from"./chunks/framework.Dxm0NwP8.js";const g=JSON.parse('{"title":"强缓存与协商缓存：提升 Web 性能的关键策略","description":"","frontmatter":{},"headers":[],"relativePath":"column/Network/Web传输/强缓存和协商缓存.md","filePath":"column/Network/Web传输/强缓存和协商缓存.md"}'),r={name:"column/Network/Web传输/强缓存和协商缓存.md"};function n(s,t,c,i,h,l){return a(),d("div",null,t[0]||(t[0]=[o('<h1 id="强缓存与协商缓存-提升-web-性能的关键策略" tabindex="-1">强缓存与协商缓存：提升 Web 性能的关键策略 <a class="header-anchor" href="#强缓存与协商缓存-提升-web-性能的关键策略" aria-label="Permalink to &quot;强缓存与协商缓存：提升 Web 性能的关键策略&quot;">​</a></h1><p>在 Web 性能优化中，缓存机制是减少网络请求、加快页面加载速度的核心技术之一。其中，<code>强缓存（Strong Cache）</code>和<code>协商缓存（Negotiation Cache）</code>是 HTTP 缓存策略的两种主要方式。</p><h2 id="_1-什么是-http-缓存" tabindex="-1"><strong>1. 什么是 HTTP 缓存？</strong> <a class="header-anchor" href="#_1-什么是-http-缓存" aria-label="Permalink to &quot;**1. 什么是 HTTP 缓存？**&quot;">​</a></h2><p>HTTP 缓存是指浏览器或代理服务器将请求过的资源（如 HTML、CSS、JS、图片等）存储起来，后续请求相同的资源时可以直接从本地或就近缓存获取，而不必重新从服务器下载。缓存机制分为两类：</p><ul><li><strong>强缓存</strong>：直接使用本地缓存，不发送请求到服务器。</li><li><strong>协商缓存</strong>：向服务器验证缓存是否可用，若可用则返回 304 状态码，否则返回新资源。</li></ul><h2 id="_2-强缓存-strong-cache" tabindex="-1"><strong>2. 强缓存（Strong Cache）</strong> <a class="header-anchor" href="#_2-强缓存-strong-cache" aria-label="Permalink to &quot;**2. 强缓存（Strong Cache）**&quot;">​</a></h2><h3 id="_2-1-工作原理" tabindex="-1"><strong>2.1 工作原理</strong> <a class="header-anchor" href="#_2-1-工作原理" aria-label="Permalink to &quot;**2.1 工作原理**&quot;">​</a></h3><p>强缓存是指浏览器在请求资源时，先检查本地缓存是否有效，如果有效则直接使用缓存，<strong>不发送 HTTP 请求</strong>到服务器。强缓存由以下两个 HTTP 头部控制：</p><table tabindex="0"><thead><tr><th>HTTP Header</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Cache-Control</code></td><td>控制缓存行为（优先级高于<code>Expires</code>）</td><td><code>Cache-Control: max-age=3600</code></td></tr><tr><td><code>Expires</code></td><td>指定资源的过期时间（HTTP/1.0，受本地时间影响）</td><td><code>Expires: Wed, 21 Oct 2025 07:28:00 GMT</code></td></tr></tbody></table><h3 id="_2-2-cache-control-常见指令" tabindex="-1"><strong>2.2 <code>Cache-Control</code> 常见指令</strong> <a class="header-anchor" href="#_2-2-cache-control-常见指令" aria-label="Permalink to &quot;**2.2 `Cache-Control` 常见指令**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>max-age=3600</code></td><td>资源缓存有效期为 3600 秒（1 小时）</td></tr><tr><td><code>no-cache</code></td><td><strong>不使用强缓存</strong>，必须向服务器验证（走协商缓存）</td></tr><tr><td><code>no-store</code></td><td><strong>禁止任何缓存</strong>，每次都要重新请求</td></tr><tr><td><code>public</code></td><td>允许代理服务器缓存（如 CDN）</td></tr><tr><td><code>private</code></td><td>仅允许浏览器缓存，不允许代理服务器缓存</td></tr></tbody></table><h3 id="_2-3-强缓存生效流程" tabindex="-1"><strong>2.3 强缓存生效流程</strong> <a class="header-anchor" href="#_2-3-强缓存生效流程" aria-label="Permalink to &quot;**2.3 强缓存生效流程**&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>浏览器请求资源 → 检查 `Cache-Control`/`Expires` → 缓存未过期 → 直接使用缓存（200 OK (from disk cache)）</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="_2-4-适用场景" tabindex="-1"><strong>2.4 适用场景</strong> <a class="header-anchor" href="#_2-4-适用场景" aria-label="Permalink to &quot;**2.4 适用场景**&quot;">​</a></h3><ul><li>静态资源（JS/CSS/图片等）长期不变，如<code>main.[hash].js</code>。</li><li>希望减少服务器请求，提升加载速度。</li></ul><h2 id="_3-协商缓存-negotiation-cache" tabindex="-1"><strong>3. 协商缓存（Negotiation Cache）</strong> <a class="header-anchor" href="#_3-协商缓存-negotiation-cache" aria-label="Permalink to &quot;**3. 协商缓存（Negotiation Cache）**&quot;">​</a></h2><h3 id="_3-1-工作原理" tabindex="-1"><strong>3.1 工作原理</strong> <a class="header-anchor" href="#_3-1-工作原理" aria-label="Permalink to &quot;**3.1 工作原理**&quot;">​</a></h3><p>协商缓存是指浏览器携带缓存标识（如<code>Last-Modified</code>或<code>ETag</code>）向服务器发起请求，服务器检查资源是否变化：</p><ul><li><strong>未变化</strong> → 返回 <code>304 Not Modified</code>，浏览器继续使用缓存。</li><li><strong>已变化</strong> → 返回 <code>200 OK</code> 和新资源。</li></ul><p>协商缓存由以下两组 HTTP 头部控制：</p><table tabindex="0"><thead><tr><th>请求头/响应头</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td><code>Last-Modified</code>（响应头）</td><td>资源最后修改时间</td><td><code>Last-Modified: Wed, 21 Oct 2025 07:28:00 GMT</code></td></tr><tr><td><code>If-Modified-Since</code>（请求头）</td><td>浏览器发送<code>Last-Modified</code>值给服务器验证</td><td><code>If-Modified-Since: Wed, 21 Oct 2025 07:28:00 GMT</code></td></tr><tr><td><code>ETag</code>（响应头）</td><td>资源的唯一标识（如哈希值）</td><td><code>ETag: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</code></td></tr><tr><td><code>If-None-Match</code>（请求头）</td><td>浏览器发送<code>ETag</code>值给服务器验证</td><td><code>If-None-Match: &quot;33a64df551425fcc55e4d42a148795d9f25f89d4&quot;</code></td></tr></tbody></table><h3 id="_3-2-协商缓存生效流程" tabindex="-1"><strong>3.2 协商缓存生效流程</strong> <a class="header-anchor" href="#_3-2-协商缓存生效流程" aria-label="Permalink to &quot;**3.2 协商缓存生效流程**&quot;">​</a></h3><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>浏览器请求资源 → 携带 `If-None-Match`/`If-Modified-Since` → 服务器检查资源是否变化 →</span></span>\n<span class="line"><span>   → 未变化（304 Not Modified） → 使用缓存</span></span>\n<span class="line"><span>   → 已变化（200 OK） → 返回新资源</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-3-etag-vs-last-modified" tabindex="-1"><strong>3.3 <code>ETag</code> vs <code>Last-Modified</code></strong> <a class="header-anchor" href="#_3-3-etag-vs-last-modified" aria-label="Permalink to &quot;**3.3 `ETag` vs `Last-Modified`**&quot;">​</a></h3><table tabindex="0"><thead><tr><th>对比项</th><th><code>ETag</code></th><th><code>Last-Modified</code></th></tr></thead><tbody><tr><td>精确度</td><td>更高（基于内容哈希）</td><td>较低（基于时间）</td></tr><tr><td>性能</td><td>计算<code>ETag</code>可能消耗服务器资源</td><td>仅记录时间，开销小</td></tr><tr><td>适用场景</td><td>频繁修改的小文件（如 JSON API）</td><td>不常修改的大文件（如图片）</td></tr></tbody></table><h3 id="_3-4-适用场景" tabindex="-1"><strong>3.4 适用场景</strong> <a class="header-anchor" href="#_3-4-适用场景" aria-label="Permalink to &quot;**3.4 适用场景**&quot;">​</a></h3><ul><li>频繁更新的资源（如用户数据 API）。</li><li>需要确保用户获取最新版本，但又希望减少带宽消耗。</li></ul><h2 id="_4-强缓存-vs-协商缓存" tabindex="-1"><strong>4. 强缓存 vs 协商缓存</strong> <a class="header-anchor" href="#_4-强缓存-vs-协商缓存" aria-label="Permalink to &quot;**4. 强缓存 vs 协商缓存**&quot;">​</a></h2><table tabindex="0"><thead><tr><th>对比项</th><th>强缓存</th><th>协商缓存</th></tr></thead><tbody><tr><td><strong>是否发送请求</strong></td><td>否</td><td>是（返回 304 或 200）</td></tr><tr><td><strong>响应状态码</strong></td><td>200 (from disk cache)</td><td>304 Not Modified</td></tr><tr><td><strong>控制字段</strong></td><td><code>Cache-Control</code>、<code>Expires</code></td><td><code>ETag</code>、<code>Last-Modified</code></td></tr><tr><td><strong>适用资源</strong></td><td>长期不变的静态资源</td><td>可能变化的动态资源</td></tr></tbody></table>',29)]))}const p=e(r,[["render",n]]);export{g as __pageData,p as default};
