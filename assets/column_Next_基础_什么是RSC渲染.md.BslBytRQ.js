import{_ as r,C as a,c as s,o as n,j as e,G as l,aQ as d,a as i}from"./chunks/framework.DEi4YP2n.js";const c="/assets/chunked.D8aShFke.png",g="/assets/chunked-1.OackMNom.png",p="/assets/chunked-2.BZdVcg2C.png",m=JSON.parse('{"title":"什么是 RSC 渲染","description":"","frontmatter":{},"headers":[],"relativePath":"column/Next/基础/什么是RSC渲染.md","filePath":"column/Next/基础/什么是RSC渲染.md","lastUpdated":1766561977000}'),h={name:"column/Next/基础/什么是RSC渲染.md"};function S(u,t,f,R,y,x){const o=a("ArticleMetadata");return n(),s("div",null,[t[0]||(t[0]=e("h1",{id:"什么是-rsc-渲染",tabindex:"-1"},[i("什么是 RSC 渲染 "),e("a",{class:"header-anchor",href:"#什么是-rsc-渲染","aria-label":'Permalink to "什么是 RSC 渲染"'},"​")],-1)),l(o),t[1]||(t[1]=d('<nav class="table-of-contents"><ul><li><a href="#一、rsc-的核心运作原理">一、RSC 的核心运作原理</a></li><li><a href="#二、开发模式-明确组件边界">二、开发模式：明确组件边界</a></li><li><a href="#三、rsc-如何与流式渲染协同">三、RSC 如何与流式渲染协同</a></li><li><a href="#四、🆚-对比传统服务端渲染-ssr">四、🆚 对比传统服务端渲染 (SSR)</a></li><li><a href="#五、如何开始使用-rsc">五、如何开始使用 RSC？</a></li><li><a href="#六、什么是水合-hydration">六、什么是水合（Hydration）？</a></li></ul></nav><p>Next.js 中的 <code>React Server Components (RSC)</code> 是一种从<strong>服务器端</strong>开始渲染组件的新型架构，它与传统的服务端渲染有本质区别。</p><h3 id="一、rsc-的核心运作原理" tabindex="-1">一、RSC 的核心运作原理 <a class="header-anchor" href="#一、rsc-的核心运作原理" aria-label="Permalink to &quot;一、RSC 的核心运作原理&quot;">​</a></h3><p>RSC 模式的关键在于服务器和浏览器的“角色”分工发生了根本变化：</p><ol><li><p><strong>服务器：“产出蓝图”</strong></p><ul><li>RSC 的代码完全在服务器端运行，<strong>不会</strong>被发送到浏览器。这可以显著减少客户端需要下载的 <code>JavaScript</code> 体积。</li><li>服务器根据请求的组件树，进行渲染和数据获取，但生成的不是最终的 HTML，而是一种被称为 <strong>RSC Payload</strong> 的特殊数据流。这个 Payload 包含了服务端组件的渲染结果、<strong>客户端组件占位符</strong>以及它们所需的数据。</li></ul></li></ol><blockquote><p>RSC 的代码里面有服务端组件和客户端组件。服务端组件负责数据获取和渲染，而客户端组件负责处理用户交互。<br> 渲染客户端组件时，只是进行占位，过程中不能进行交互。</p></blockquote><ol start="2"><li><strong>浏览器：“按图组装”</strong><ul><li>浏览器接收到的就是这份“蓝图”（RSC Payload）。它基于这份数据，在本地精确地协调（Reconcile）出用户界面。</li><li>对于页面中需要交互的部分（如按钮、表单），对应的客户端组件代码会按需加载并“水合”（Hydrate），使其变得可交互。</li></ul></li></ol><h3 id="二、开发模式-明确组件边界" tabindex="-1">二、开发模式：明确组件边界 <a class="header-anchor" href="#二、开发模式-明确组件边界" aria-label="Permalink to &quot;二、开发模式：明确组件边界&quot;">​</a></h3><p>在开发中，你需要清晰地区分两类组件：</p><ul><li><strong>服务端组件 (默认)</strong>：用于处理<strong>数据获取</strong>（如直接连接数据库）和<strong>静态内容渲染</strong>。它们<strong>不能</strong>使用状态（<code>useState</code>）、生命周期（<code>useEffect</code>）或浏览器 API。</li><li><strong>客户端组件</strong>：用于处理<strong>用户交互</strong>和<strong>状态管理</strong>。需要在文件顶部添加 <code>&#39;use client&#39;</code> 指令来显式声明。</li></ul><p>一个典型的模式是：在服务器端组件中获取数据，然后将数据作为 <code>props</code> 传递给嵌套的客户端子组件。</p><h3 id="三、rsc-如何与流式渲染协同" tabindex="-1">三、RSC 如何与流式渲染协同 <a class="header-anchor" href="#三、rsc-如何与流式渲染协同" aria-label="Permalink to &quot;三、RSC 如何与流式渲染协同&quot;">​</a></h3><p>RSC 的强大之处在于它能与 React 的 <code>Suspense</code> 结合，实现流式渲染：</p><ul><li>当页面的某个部分（如一个依赖慢速 API 的评论模块）还在加载时，<code>Suspense</code> 允许你先发送页面的其余部分（如文章主体）到浏览器，并用占位符（<code>fallback</code>）替代未就绪的部分。</li><li>当该部分的数据在服务器端准备完毕后，对应的 <code>RSC Payload </code>片段会以“流”（Stream）的形式实时发送到浏览器，无缝插入到页面中。</li></ul><div class="tip custom-block"><p class="custom-block-title">transfer-encoding:chunked(另一种流式传输 )</p><p>服务端以 <code>transfer-encoding:chunked</code> 方式发送<code> RSC Payload</code>，浏览器端接收后，根据 <code>Payload</code> 中的占位符，逐步协调出用户界面。但是这种方式有一个问题，就是浏览器端需要等待所有的 <code>Payload</code> 片段都接收完毕，用户才能交互界面。</p></div><p><strong>如图：</strong></p><p><img src="'+c+'" alt="transfer-encoding:chunked" loading="lazy"></p><h4 id="下面是渲染流程图" tabindex="-1">下面是渲染流程图 <a class="header-anchor" href="#下面是渲染流程图" aria-label="Permalink to &quot;下面是渲染流程图&quot;">​</a></h4><p><img src="'+g+'" alt="chunked-1" width="50%" loading="lazy"></p><h3 id="四、🆚-对比传统服务端渲染-ssr" tabindex="-1">四、🆚 对比传统服务端渲染 (SSR) <a class="header-anchor" href="#四、🆚-对比传统服务端渲染-ssr" aria-label="Permalink to &quot;四、🆚 对比传统服务端渲染 (SSR)&quot;">​</a></h3><p>下表清晰地展示了 RSC 与 Next.js 早期 Pages Router 中 SSR 的主要区别：</p><table tabindex="0"><thead><tr><th style="text-align:left;">特性</th><th style="text-align:left;">RSC (App Router)</th><th style="text-align:left;">传统 SSR (Pages Router)</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>渲染单元</strong></td><td style="text-align:left;"><strong>组件级</strong>。页面可以混合使用服务端和客户端组件。</td><td style="text-align:left;"><strong>页面级</strong>。一个页面要么整个在服务端渲染，要么在客户端渲染。</td></tr><tr><td style="text-align:left;"><strong>输出物</strong></td><td style="text-align:left;"><strong>RSC Payload（数据流）</strong> + 初始 HTML 骨架。</td><td style="text-align:left;"><strong>完整的 HTML 字符串</strong>，其中内嵌了序列化的页面数据（脱水）。</td></tr><tr><td style="text-align:left;"><strong>水合方式</strong></td><td style="text-align:left;"><strong>部分水合</strong>。仅对客户端组件进行水合，服务端组件无需水合。</td><td style="text-align:left;"><strong>全量水合</strong>。浏览器需要下载并执行整个页面的 JS，与水合完整的 DOM 树。</td></tr><tr><td style="text-align:left;"><strong>数据获取</strong></td><td style="text-align:left;">组件内部可直接进行异步数据获取（<code>async/await</code>），无需额外 API 层。</td><td style="text-align:left;">通常通过 <code>getServerSideProps</code> 等特定函数在页面级获取数据。</td></tr><tr><td style="text-align:left;"><strong>代码体积</strong></td><td style="text-align:left;">更优。服务端组件代码<strong>零客户端打包体积</strong>。</td><td style="text-align:left;">较大。页面的所有组件代码（无论是否交互）最终都会被打包发送到客户端。</td></tr></tbody></table><h3 id="五、如何开始使用-rsc" tabindex="-1">五、如何开始使用 RSC？ <a class="header-anchor" href="#五、如何开始使用-rsc" aria-label="Permalink to &quot;五、如何开始使用 RSC？&quot;">​</a></h3><p>从 <strong>Next.js 13</strong> 开始，使用新的 <strong>App Router</strong> 是体验 RSC 的最佳方式。</p><ol><li><strong>默认</strong>：在 <code>app</code> 目录下的组件都是<strong>服务端组件</strong>。</li><li><strong>交互需求</strong>：在需要交互的组件文件顶部添加 <code>&#39;use client&#39;</code> 指令，将其变为客户端组件。</li><li><strong>性能优化</strong>：对于数据加载较慢的组件，用 <code>Suspense</code> 包裹以实现流式渲染。</li></ol><p>总而言之，RSC 在 Next.js 中代表了一种更智能的渲染模型，它通过在服务器和客户端之间进行更精细的职责划分，旨在实现更快的加载速度、更小的客户端包体积和更流畅的用户体验。</p><h3 id="六、什么是水合-hydration" tabindex="-1">六、什么是水合（Hydration）？ <a class="header-anchor" href="#六、什么是水合-hydration" aria-label="Permalink to &quot;六、什么是水合（Hydration）？&quot;">​</a></h3><p><strong>水合</strong>是<strong>将交互功能“注入”到服务端预先生成的静态 HTML 页面中的过程</strong>，让页面从“只读”变为“可交互”。</p><p><strong>核心类比</strong>：就像泡一碗速食面——服务器给你一碗<strong>熟的、看得见的</strong>面条（静态 HTML），浏览器再倒入调料包和开水（JavaScript），你才能<strong>吃到有味道的</strong>面（可交互页面）。</p><p><strong>关键要点</strong>：</p><ol><li><strong>目的</strong>：解决“先快速显示内容，再补充交互能力”的矛盾。</li><li><strong>过程</strong>：React 将事件处理器、状态管理等“附加”到已有的 DOM 节点上，并接管后续更新。</li><li><strong>革新</strong>：Next.js 的<strong>RSC 支持“部分水合”</strong>，只对标记为 <code>‘use client’</code> 的交互组件进行水合，<strong>大幅减少 JavaScript 负载，使页面可交互时间显著提前</strong>。</li></ol><p>简单来说，水合就是 <strong>让已经显示出来的页面“活过来”</strong> 的最后一步关键操作。</p><p><strong>如下图：</strong></p><p>服务端提前把节点渲染出来，但是浏览器端需要等待所有的 <code>Payload</code> 片段都接收完毕，用户才能交互界面。<br> 让用户先看到东西。</p><p><img src="'+p+'" alt="chunked-2" loading="lazy"></p>',35))])}const _=r(h,[["render",S]]);export{m as __pageData,_ as default};
