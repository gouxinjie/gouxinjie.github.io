import{_ as i,c as a,o as n,aQ as e}from"./chunks/framework.CZC_k6km.js";const d=JSON.parse('{"title":"利用 useEffect 处理竟态操作","description":"","frontmatter":{},"headers":[],"relativePath":"column/React/副作用/利用useEffect处理竟态操作.md","filePath":"column/React/副作用/利用useEffect处理竟态操作.md","lastUpdated":1757039663000}'),l={name:"column/React/副作用/利用useEffect处理竟态操作.md"};function t(p,s,h,r,k,E){return n(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="利用-useeffect-处理竟态操作" tabindex="-1">利用 useEffect 处理竟态操作 <a class="header-anchor" href="#利用-useeffect-处理竟态操作" aria-label="Permalink to &quot;利用 useEffect 处理竟态操作&quot;">​</a></h1><hr><nav class="table-of-contents"><ul><li><a href="#一、什么是竟态操作">一、什么是竟态操作</a></li><li><a href="#二、abortcontroller-方案-中断请求">二、AbortController 方案（中断请求）</a></li><li><a href="#三、闭包方案-推荐-不中断请求">三、闭包方案（推荐-不中断请求）</a></li><li><a href="#四、useeffect-清理函数的执行时机">四、useEffect 清理函数的执行时机</a></li></ul></nav><h2 id="一、什么是竟态操作" tabindex="-1">一、什么是竟态操作 <a class="header-anchor" href="#一、什么是竟态操作" aria-label="Permalink to &quot;一、什么是竟态操作&quot;">​</a></h2><p>例如有一个实时搜索功能，用户输入查询字符串，后端返回搜索结果。先发起的请求可能比后发起的请求更晚返回，导致显示错误用户的数据。解决这个问题就是一旦新的请求发起那么就中断旧的请求，无论旧的请求是否成功。</p><p><strong>下面是两种方案：</strong></p><ul><li><code>AbortController</code>方案就是使用构造函数创建一个控制器实例来进行中断。</li></ul><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> controller</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbortController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">controller.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">abort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>利用 <code>useEffect</code> 的清理函数不进行请求的中断，直接舍弃过时的数据。</li></ul><h2 id="二、abortcontroller-方案-中断请求" tabindex="-1">二、AbortController 方案（中断请求） <a class="header-anchor" href="#二、abortcontroller-方案-中断请求" aria-label="Permalink to &quot;二、AbortController 方案（中断请求）&quot;">​</a></h2><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> controller</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbortController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fetchResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(query, { signal: controller.signal })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(setResults)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (e.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;AbortError&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(e);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> controller.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">abort</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [query]);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="三、闭包方案-推荐-不中断请求" tabindex="-1">三、闭包方案（推荐-不中断请求） <a class="header-anchor" href="#三、闭包方案-推荐-不中断请求" aria-label="Permalink to &quot;三、闭包方案（推荐-不中断请求）&quot;">​</a></h2><div class="language-tsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ignore </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 标志位初始为false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fetchResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(query).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">json</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ignore) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setResults</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(json); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只有ignore为false时才更新状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ignore </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 清理函数中将ignore置为true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, [query]);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>上面代码执行的顺序如下：</strong></p><p>1，组件挂载/query 更新：每次 query 变化时，effect 重新执行。<br> 2，发起请求前：声明局部变量 ignore = false。<br> 3，请求完成后：检查 ignore，若为 false 则更新状态。<br> 4，清理阶段：当 effect 再次执行（即 query 再次变化）或组件卸载时，会执行前一个 effect 的清理函数，将 ignore 设为 true，使之前的请求即使返回也不会更新状态</p><p><strong>也就是说：</strong><br></p><p>✅ 每次输入都会触发独立的 effect 回调<br> ✅ 每个回调都有自己独立的 ignore 变量（通过闭包隔离）<br> ✅ 多个请求可能同时存在，但只有最新一个能生效</p><div class="tip custom-block"><p class="custom-block-title">关键特性：</p><ul><li>闭包监狱：每个 ignore 被锁在自己的 effect 作用域里，互不干扰</li><li>清理链：新 effect 执行前，React 保证会执行前一个 effect 的清理函数</li><li>并行但受控：多个请求可能同时进行，但只有最新 effect 的 ignore 是 false</li></ul></div><h2 id="四、useeffect-清理函数的执行时机" tabindex="-1">四、useEffect 清理函数的执行时机 <a class="header-anchor" href="#四、useeffect-清理函数的执行时机" aria-label="Permalink to &quot;四、useEffect 清理函数的执行时机&quot;">​</a></h2><p><code>useEffect</code>清理函数会在组件卸载时和依赖项变化时进行执行。</p><p>1, <strong>组件卸载时</strong>（<code>unmount</code>）</p><ul><li>当组件从 DOM 中移除时，React 会执行清理函数。</li><li>例如：页面跳转、组件被条件渲染移除时。</li></ul><p>2, <strong>依赖项变化，导致 <code>useEffect</code> 重新执行前</strong></p><ul><li><strong>在下一次 <code>useEffect</code> 执行之前</strong>，React 会先执行上一次的清理函数。</li><li>例如：<code>query</code> 变化时，会先清理旧的 <code>useEffect</code>，再运行新的 <code>useEffect</code>。</li></ul>`,24)])])}const o=i(l,[["render",t]]);export{d as __pageData,o as default};
