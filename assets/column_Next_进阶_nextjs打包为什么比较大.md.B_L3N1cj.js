import{_ as s,C as n,c as i,o as l,j as a,G as r,aQ as o,a as d}from"./chunks/framework.DEi4YP2n.js";const p="/assets/next-dist.4wxc2ZOV.png",j=JSON.parse('{"title":"为什么 Next.js 打包比 Vue/React 大？","description":"","frontmatter":{},"headers":[],"relativePath":"column/Next/进阶/nextjs打包为什么比较大.md","filePath":"column/Next/进阶/nextjs打包为什么比较大.md","lastUpdated":1763362911000}'),c={name:"column/Next/进阶/nextjs打包为什么比较大.md"};function u(h,e,b,m,g,x){const t=n("ArticleMetadata");return l(),i("div",null,[e[0]||(e[0]=a("h1",{id:"为什么-next-js-打包比-vue-react-大",tabindex:"-1"},[d("为什么 Next.js 打包比 Vue/React 大？ "),a("a",{class:"header-anchor",href:"#为什么-next-js-打包比-vue-react-大","aria-label":'Permalink to "为什么 Next.js 打包比 Vue/React 大？"'},"​")],-1)),r(t),e[1]||(e[1]=o('<nav class="table-of-contents"><ul><li><a href="#原因-1-next-js-默认包含-ssr-rsc-edge-runtime-等功能">原因 1：Next.js 默认包含 SSR / RSC / Edge Runtime 等功能</a></li><li><a href="#原因-2-next-js-每个路由都有-server-client-bundling">原因 2：Next.js 每个路由都有 Server &amp; Client bundling</a></li><li><a href="#原因-3-next-js-默认使用-react-体积比-vue-大">原因 3：Next.js 默认使用 React，体积比 Vue 大</a></li><li><a href="#原因-4-next-js-的构建产物包含大量元数据和中间产物">原因 4：Next.js 的构建产物包含大量元数据和中间产物</a></li><li><a href="#原因-5-你看到的体积并不是浏览器实际加载的大小">原因 5：你看到的体积并不是浏览器实际加载的大小</a></li><li><a href="#那为什么-vue-react-看起来小很多">那为什么 Vue / React 看起来小很多？</a></li><li><a href="#如何判断真实的页面体积">如何判断真实的页面体积？</a></li><li><a href="#如何减少-next-js-客户端包体积">如何减少 Next.js 客户端包体积？</a></li><li><a href="#_1-减少-client-component-改为-server-component">1. 减少 client component，改为 server component</a></li><li><a href="#_2-使用-dynamic-分包加载">2. 使用 dynamic() 分包加载</a></li><li><a href="#_3-去掉运行时-polyfills">3. 去掉运行时 polyfills</a></li><li><a href="#_4-打开-swc-压缩">4. 打开 SWC 压缩</a></li><li><a href="#_5-依赖优化">5. 依赖优化</a></li></ul></nav><p><code>Next.js </code>打包体积“看起来”比 Vue/React 更大，这是非常常见的现象，但这并不是因为 Next.js 本身臃肿，而是由于 <strong>SSR / 路由机制 / 打包模式 / 产物结构</strong> 等带来的客观差异。</p><h2 id="原因-1-next-js-默认包含-ssr-rsc-edge-runtime-等功能" tabindex="-1"><strong>原因 1：Next.js 默认包含 SSR / RSC / Edge Runtime 等功能</strong> <a class="header-anchor" href="#原因-1-next-js-默认包含-ssr-rsc-edge-runtime-等功能" aria-label="Permalink to &quot;**原因 1：Next.js 默认包含 SSR / RSC / Edge Runtime 等功能**&quot;">​</a></h2><p>Vue（Vite）、Create React App、React + Vite 本质上都是 <strong>纯前端 SPA</strong>。</p><p>但 Next.js 是 <strong>全栈框架</strong>，打包产物包含更多内容：</p><table tabindex="0"><thead><tr><th>内容</th><th>Vue/React SPA</th><th>Next.js</th></tr></thead><tbody><tr><td>客户端 JS</td><td>✔️</td><td>✔️</td></tr><tr><td>SSR 渲染代码</td><td>❌</td><td>✔️</td></tr><tr><td>服务端路由代码</td><td>❌</td><td>✔️</td></tr><tr><td>API Routes / Server Actions</td><td>❌</td><td>✔️</td></tr><tr><td>Edge Runtime / Node runtime</td><td>❌</td><td>✔️</td></tr><tr><td>两套 bundle（客户端+服务端）</td><td>❌</td><td>✔️</td></tr></tbody></table><p>➡️ <strong>你看到的 <code>.next</code> 目录体积大，是因为它包含了客户端 + 服务端 两份产物</strong>。</p><p>Vue/React 只生成客户端 bundle，所以自然更小。</p><h2 id="原因-2-next-js-每个路由都有-server-client-bundling" tabindex="-1"><strong>原因 2：Next.js 每个路由都有 Server &amp; Client bundling</strong> <a class="header-anchor" href="#原因-2-next-js-每个路由都有-server-client-bundling" aria-label="Permalink to &quot;**原因 2：Next.js 每个路由都有 Server &amp; Client bundling**&quot;">​</a></h2><p>例如 <code>/dashboard</code> 这个页面：</p><p>Next.js 会生成：</p><ul><li><code>/dashboard</code> —— SSR 渲染代码（Server 端）</li><li><code>/dashboard.client.js</code> —— 客户端 hydration 脚本</li><li>shared chunks</li><li>以及 RSC 文件（如你用到 App Router）</li></ul><p>而 Vue/React SPA 只有：</p><ul><li><code>/assets/dashboard.xxx.js</code>（纯客户端）</li></ul><p>➡️ <strong>多了一倍甚至数倍的文件数量</strong>。</p><h2 id="原因-3-next-js-默认使用-react-体积比-vue-大" tabindex="-1"><strong>原因 3：Next.js 默认使用 React，体积比 Vue 大</strong> <a class="header-anchor" href="#原因-3-next-js-默认使用-react-体积比-vue-大" aria-label="Permalink to &quot;**原因 3：Next.js 默认使用 React，体积比 Vue 大**&quot;">​</a></h2><p>React 本身体积（大约 42kb gzip）比 Vue（大约 20kb gzip）更大。</p><p>分别看 SPA 打包：</p><ul><li>Vue：生产包非常小</li><li>React：会大一些</li><li>Next.js：因为 React + SSR + Routing + Runtime → 自然再大一些</li></ul><h2 id="原因-4-next-js-的构建产物包含大量元数据和中间产物" tabindex="-1"><strong>原因 4：Next.js 的构建产物包含大量元数据和中间产物</strong> <a class="header-anchor" href="#原因-4-next-js-的构建产物包含大量元数据和中间产物" aria-label="Permalink to &quot;**原因 4：Next.js 的构建产物包含大量元数据和中间产物**&quot;">​</a></h2><p><code>.next</code> 目录里包含：</p><ul><li><strong>server</strong></li><li><strong>server/chunks</strong></li><li><strong>server/app</strong>（App Router）</li><li><strong>server/pages</strong>（如果使用）</li><li><strong>client</strong></li><li><strong>client/chunks</strong></li><li><strong>middleware</strong></li><li><strong>img optimizer files</strong></li><li><strong>webpack cache</strong></li><li><strong>server build manifest</strong></li></ul><p><strong>如下：</strong></p><p><img src="'+p+`" alt="next-dist" loading="lazy"></p><p>Vue 和 Vite + React 的 <code>dist/</code> 目录基本只包含：</p><ul><li>js</li><li>css</li><li>assets</li></ul><p>➡️ Next.js 多产物、多层级，体积看起来巨大。</p><h2 id="原因-5-你看到的体积并不是浏览器实际加载的大小" tabindex="-1"><strong>原因 5：你看到的体积并不是浏览器实际加载的大小</strong> <a class="header-anchor" href="#原因-5-你看到的体积并不是浏览器实际加载的大小" aria-label="Permalink to &quot;**原因 5：你看到的体积并不是浏览器实际加载的大小**&quot;">​</a></h2><p>你看的是 <code>.next</code> 文件夹大小，例如：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.next</span></span>
<span class="line"><span>  ├─ server/ 200MB</span></span>
<span class="line"><span>  ├─ static/ 10MB</span></span>
<span class="line"><span>  ├─ cache/ 700MB</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>但浏览器实际只会下载：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>.next/static/chunks/*.js</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这些一般是几十 KB 到几百 KB <strong>gzip 后通常不超过 200KB</strong>。</p><p><strong>真实访问量远小于打包产物体积，看起来大但不会全部被客户端下载。</strong></p><h2 id="那为什么-vue-react-看起来小很多" tabindex="-1">那为什么 Vue / React 看起来小很多？ <a class="header-anchor" href="#那为什么-vue-react-看起来小很多" aria-label="Permalink to &quot;那为什么 Vue / React 看起来小很多？&quot;">​</a></h2><p>理由简单：</p><table tabindex="0"><thead><tr><th>框架</th><th>构建内容</th></tr></thead><tbody><tr><td>Vue / Vite</td><td>纯客户端（只有生产可用的文件）</td></tr><tr><td>React SPA</td><td>纯客户端（只有生产可用的文件）</td></tr><tr><td>Next.js</td><td>客户端 + 服务端 + SSR + RSC +路由 +运行时环境 +元数据</td></tr></tbody></table><p>Next 就像：</p><blockquote><p>你让它做饭 → 它把厨房也一起打包了。</p></blockquote><p>Vue/React：</p><blockquote><p>只把做好的一盘菜给你。</p></blockquote><h2 id="如何判断真实的页面体积" tabindex="-1">如何判断真实的页面体积？ <a class="header-anchor" href="#如何判断真实的页面体积" aria-label="Permalink to &quot;如何判断真实的页面体积？&quot;">​</a></h2><p>运行：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>next build &amp;&amp; next analyze</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>或使用插件：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>next-bundle-analyzer</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后你会看到：</p><ul><li>浏览器实际下载的 js <strong>并不大</strong></li><li>很多 server-side 代码不会被客户端下载</li><li>图片优化、中间产物、缓存都占了体积，但不影响最终体积</li></ul><h2 id="如何减少-next-js-客户端包体积" tabindex="-1">如何减少 Next.js 客户端包体积？ <a class="header-anchor" href="#如何减少-next-js-客户端包体积" aria-label="Permalink to &quot;如何减少 Next.js 客户端包体积？&quot;">​</a></h2><p>下面是实际有效且常见的方法：</p><h2 id="_1-减少-client-component-改为-server-component" tabindex="-1">1. <strong>减少 client component，改为 server component</strong> <a class="header-anchor" href="#_1-减少-client-component-改为-server-component" aria-label="Permalink to &quot;1. **减少 client component，改为 server component**&quot;">​</a></h2><p>App Router 最大优点就是：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>默认是服务器组件，只有你写 &quot;use client&quot; 才会成为客户端组件。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><strong>越少 use client → 客户端包越小</strong>。</p><h2 id="_2-使用-dynamic-分包加载" tabindex="-1">2. 使用 <code>dynamic()</code> 分包加载 <a class="header-anchor" href="#_2-使用-dynamic-分包加载" aria-label="Permalink to &quot;2. 使用 \`dynamic()\` 分包加载&quot;">​</a></h2><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>const Chart = dynamic(() =&gt; import(&quot;./Chart&quot;), { ssr: false });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_3-去掉运行时-polyfills" tabindex="-1">3. 去掉运行时 polyfills <a class="header-anchor" href="#_3-去掉运行时-polyfills" aria-label="Permalink to &quot;3. 去掉运行时 polyfills&quot;">​</a></h2><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>next.config.js:</span></span>
<span class="line"><span>experimental: {</span></span>
<span class="line"><span>  optimizePackageImports: [&#39;lodash&#39;, &#39;date-fns&#39;]</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_4-打开-swc-压缩" tabindex="-1">4. 打开 SWC 压缩 <a class="header-anchor" href="#_4-打开-swc-压缩" aria-label="Permalink to &quot;4. 打开 SWC 压缩&quot;">​</a></h2><p>Next.js 默认开启，但可以确保启用：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>swcMinify: true,</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="_5-依赖优化" tabindex="-1">5. 依赖优化 <a class="header-anchor" href="#_5-依赖优化" aria-label="Permalink to &quot;5. 依赖优化&quot;">​</a></h2><p>比如避免：</p><ul><li>lodash（改用 lodash-es 按需）</li><li>moment（体积巨大，改成 dayjs）</li><li>antd 全量引入（按需引入）</li></ul>`,64))])}const k=s(c,[["render",u]]);export{j as __pageData,k as default};
