import{_ as a,c as e,o as n,aP as p}from"./chunks/framework.Dxm0NwP8.js";const i="/assets/install-1.D00s2kDY.png",l="/assets/install-2.D0ws1F1V.png",o="/assets/install-3.BDj1sjd9.png",c="/assets/install-4.aZvtygDP.png",t="/assets/install-5.-gosgwc0.png",_=JSON.parse('{"title":"Npm install 原理","description":"","frontmatter":{},"headers":[],"relativePath":"column/Node/基础/npm install原理.md","filePath":"column/Node/基础/npm install原理.md"}'),d={name:"column/Node/基础/npm install原理.md"};function r(h,s,m,k,g,u){return n(),e("div",null,s[0]||(s[0]=[p('<h1 id="npm-install-原理" tabindex="-1">Npm install 原理 <a class="header-anchor" href="#npm-install-原理" aria-label="Permalink to &quot;Npm install 原理&quot;">​</a></h1><h2 id="_1、在执行-npm-install-的时候发生了什么" tabindex="-1">1、在执行 npm install 的时候发生了什么？ <a class="header-anchor" href="#_1、在执行-npm-install-的时候发生了什么" aria-label="Permalink to &quot;1、在执行 npm install 的时候发生了什么？&quot;">​</a></h2><p>首先安装的依赖都会存放在根目录的<code>node_modules</code>,默认采用<code>扁平化</code>的方式安装，并且排序规则<code>.bin第一个</code>然后<code>@开头的</code>系列，再然后按照首字母排序<code>abcd...</code>等，并且使用的算法是<code>广度优先遍历</code>，在遍历依赖树时，<code>npm</code>会首先处理项目根目录下的依赖，然后逐层处理每个依赖包的依赖，直到所有依赖都被处理完毕。</p><p>在处理每个依赖时，npm 会检查该依赖的版本号是否符合依赖树中其他依赖的版本要求，如果不符合，则会尝试安装适合的版本。</p><p><strong>如下图所示：</strong></p><p><img src="'+i+`" alt="npm install 原理"></p><h2 id="_2、扁平化" tabindex="-1">2、扁平化 <a class="header-anchor" href="#_2、扁平化" aria-label="Permalink to &quot;2、扁平化&quot;">​</a></h2><p>npm 从 v3 开始默认采用扁平化（flat）方式安装依赖。</p><p><strong>npm 扁平化的特点：依赖提升（Hoisting）</strong></p><p>将子依赖尽可能提升到项目根目录的 <code>node_modules</code> 中。<br> 例如：若<code>A</code>和<code>B</code>都依赖<code> @1.0.0</code>，则 <code>@1.0.0</code> 会被提升到顶层。</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules/</span></span>
<span class="line"><span>├── A/               # 项目直接依赖 A@1.0.0</span></span>
<span class="line"><span>├── B/               # 项目直接依赖 B@1.0.0</span></span>
<span class="line"><span>│</span></span>
<span class="line"><span>└── C@1.0.0          # 被提升到顶层的公共依赖</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果：项目依赖 <code>A@1.0.0 </code>和 <code>B@1.0.0</code>，且： <code>A</code> 依赖 <code>C@1.0.0</code> <code>B</code> 依赖 <code>C@2.0.0</code></p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules/</span></span>
<span class="line"><span>├── A/               # 主依赖A</span></span>
<span class="line"><span>│   └── (隐式使用顶层的C@1.0.0)</span></span>
<span class="line"><span>├── B/               # 主依赖B</span></span>
<span class="line"><span>│   └── node_modules/</span></span>
<span class="line"><span>│       └── C@2.0.0  # 冲突版本被迫嵌套</span></span>
<span class="line"><span>└── C@1.0.0          # 被提升到顶层的公共依赖</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_3、npm-install-执行流程" tabindex="-1">3、npm install 执行流程 <a class="header-anchor" href="#_3、npm-install-执行流程" aria-label="Permalink to &quot;3、npm install 执行流程&quot;">​</a></h2><h3 id="_3-1-检查-package-json" tabindex="-1">3.1 检查 package.json <a class="header-anchor" href="#_3-1-检查-package-json" aria-label="Permalink to &quot;3.1 检查 package.json&quot;">​</a></h3><p>npm 首先会读取当前目录下的 package.json 文件，解析其中的依赖项：</p><p><code>dependencies</code>：生产环境依赖（通过 <code>npm install</code> 或者 添加）。</p><p><code>devDependencies</code>：开发环境依赖（通过 <code>npm install --save-dev</code> 添加）。</p><p><code>peerDependencies</code>：宿主环境需提供的依赖（常见于插件开发）。</p><p><code>optionalDependencies</code>：可选依赖（安装失败不会中断流程）。</p><h3 id="_3-2-生成或更新-package-lock-json" tabindex="-1">3.2 生成或更新 package-lock.json <a class="header-anchor" href="#_3-2-生成或更新-package-lock-json" aria-label="Permalink to &quot;3.2 生成或更新 package-lock.json&quot;">​</a></h3><p>如果存在<code> package-lock.json</code> 或 <code>npm-shrinkwrap.json</code>，<code>npm</code> 会严格按锁文件中的版本安装，确保依赖树的一致性。</p><p>如果没有锁文件，<code>npm</code> 会根据 <code>package.json</code> 中的版本规则（如 ^1.2.0）下载最新兼容版本，并生成新的 <code>package-lock.json</code>。</p><h3 id="_3-3-下载依赖包" tabindex="-1">3.3 下载依赖包 <a class="header-anchor" href="#_3-3-下载依赖包" aria-label="Permalink to &quot;3.3 下载依赖包&quot;">​</a></h3><p>npm 从配置的 registry（默认是 <a href="https://registry.npmjs.org" target="_blank" rel="noreferrer">https://registry.npmjs.org</a>）下载依赖包。</p><p><strong>配置查看：</strong></p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">npm config list</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="`+l+`" alt=""></p><p>下载的包会被缓存到本地（路径可通过<code> npm config get cache</code> 查看），后续安装会优先使用缓存。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">npm config get cache</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:\\Users\\xinjie\\AppData\\Local\\npm</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cache  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 复制路径直接到文件资源管理器</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如下是我项目中的依赖缓存：</p><p><img src="`+o+`" alt="get cache"></p><h3 id="_3-4-解析依赖树" tabindex="-1">3.4 解析依赖树 <a class="header-anchor" href="#_3-4-解析依赖树" aria-label="Permalink to &quot;3.4 解析依赖树&quot;">​</a></h3><p><code>npm</code> 分析每个依赖包的<code> package.json</code>，递归安装它们的子依赖，构建完整的依赖树。</p><p>如果发现版本冲突（如 A 需要 lodash@4.x，B 需要 lodash@3.x），npm 会尝试在依赖树的不同层级安装不同版本（嵌套依赖）。</p><h3 id="_3-5-扁平化依赖-dedupe" tabindex="-1">3.5 扁平化依赖（Dedupe） <a class="header-anchor" href="#_3-5-扁平化依赖-dedupe" aria-label="Permalink to &quot;3.5 扁平化依赖（Dedupe）&quot;">​</a></h3><p><code>npm v3+</code> 会尝试“扁平化”依赖树，将重复的依赖提升到顶层<code> node_modules</code>，减少冗余。例如：</p><div class="language-text vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules/</span></span>
<span class="line"><span>├─ lodash@4.17.21    # 被提升到顶层</span></span>
<span class="line"><span>├─ A/                # A 需要 lodash@4.x</span></span>
<span class="line"><span>└─ B/</span></span>
<span class="line"><span>    └─ node_modules/</span></span>
<span class="line"><span>        └─ lodash@3.10.1  # B 需要 lodash@3.x，无法扁平化</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_3-6-执行生命周期脚本" tabindex="-1">3.6 执行生命周期脚本 <a class="header-anchor" href="#_3-6-执行生命周期脚本" aria-label="Permalink to &quot;3.6 执行生命周期脚本&quot;">​</a></h3><p>安装完成后，npm 会按顺序执行包中定义的生命周期脚本（如果存在）：</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">preinstall</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> →</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> →</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> postinstall</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>例如，某些包（如<code> node-sass</code>）会在 <code>postinstall</code> 阶段编译原生代码。</p><h3 id="_3-7-创建-node-modules-目录" tabindex="-1">3.7 创建 node_modules 目录 <a class="header-anchor" href="#_3-7-创建-node-modules-目录" aria-label="Permalink to &quot;3.7 创建 node_modules 目录&quot;">​</a></h3><p>所有依赖（包括子依赖）会被安装到 <code>node_modules</code> 目录中。如果使用<code> npm ci</code>（用于 CI 环境），会先删除现有 <code>node_modules</code>，严格按锁文件安装。</p><h3 id="_3-8-常见问题" tabindex="-1">3.8 常见问题 <a class="header-anchor" href="#_3-8-常见问题" aria-label="Permalink to &quot;3.8 常见问题&quot;">​</a></h3><p>权限错误：在 <code>Linux/macOS </code>下，避免用 <code>sudo</code>，建议用 <code>nvm</code> 管理 <code>Node.js</code> 或修复<code> npm</code> 目录权限。</p><p>网络问题：可切换 registry（如淘宝镜像：npm config set registry <a href="https://registry.npmmirror.com" target="_blank" rel="noreferrer">https://registry.npmmirror.com</a>）。</p><p>版本冲突：依赖冲突时，可通过 npm ls <code>&lt;package&gt;</code> 查看依赖路径，或使用 npm dedupe 优化。</p><h2 id="_4、-npmrc-文件" tabindex="-1">4、.npmrc 文件 <a class="header-anchor" href="#_4、-npmrc-文件" aria-label="Permalink to &quot;4、.npmrc 文件&quot;">​</a></h2><p><code>.npmrc</code>（npm runtime configuration）是 <code>npm</code> 的配置文件，用于定义 包安装、发布、认证等行为的规则。它可以存在于不同层级（全局、用户、项目级），优先级从高到低为：</p><p>项目级 &gt; 用户级 &gt; 全局 &gt; npm 默认值。</p><p><strong>常见配置项:</strong></p><div class="language-ini vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ini</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 示例：项目级 .npmrc</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">registry</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=https://registry.npmmirror.com  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 镜像源</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">save-exact</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=true                         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 保存精确版本（非语义化版本^/~）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">strict-ssl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=false                        </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 跳过HTTPS证书验证（企业代理场景）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=http://company-proxy.com:8080     </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设置代理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">engine-strict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>核心用途</strong></p><p>切换镜像源：加速依赖下载（如淘宝镜像）。<br> 控制版本保存规则：避免 package.json 中自动添加 ^ 或 ~。<br> 安全与代理：处理企业内网认证或代理问题。<br> 覆盖默认行为：例如禁用脚本执行（ignore-scripts=true）。</p><p><strong>文件位置</strong></p><p>项目级：./.npmrc（与 package.json 同级）。<br> 用户级：~/.npmrc（用户主目录）。<br> 全局：/etc/npmrc（系统级）。</p><h2 id="_5、package-lock-json-文件" tabindex="-1">5、package-lock.json 文件 <a class="header-anchor" href="#_5、package-lock-json-文件" aria-label="Permalink to &quot;5、package-lock.json 文件&quot;">​</a></h2><p><code>package-lock.json</code> 是 npm v5+ 自动生成的锁文件，精确描述依赖树的结构和所有子依赖的版本，确保每次安装结果完全一致（无论何时何地）。</p><p><code>version</code> 该参数指定了当前包的版本号 <code>resolved</code> 该参数指定了当前包的下载地址 <code>integrity</code> 用于验证包的完整性 <code>dev</code> 该参数指定了当前包是一个开发依赖包 <code>bin</code> 该参数指定了当前包中可执行文件的路径和名称 <code>engines</code> 该参数指定了当前包所依赖的 Node.js 版本范围</p><p><strong>注意：</strong></p><p><code>package-lock.json</code> 帮我们做了缓存，他会通过<code> name + version + integrity</code> 信息生成一个唯一的 key，这个 key 能找到对应的<code>index-v5</code> 下的缓存记录 也就是<code>npm cache</code> 文件夹下的。</p><p><img src="`+c+'" alt="get cache" width="80%"></p><p>如果发现有缓存记录，就会找到 tar 包的 hash 值，然后将对应的二进制文件解压到 <code>node_modeules</code></p><p><img src="'+t+'" alt="get cache"></p>',65)]))}const v=a(d,[["render",r]]);export{_ as __pageData,v as default};
